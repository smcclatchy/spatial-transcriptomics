<!DOCTYPE html>
<!-- START: inst/pkgdown/templates/layout.html --><!-- Generated by pkgdown: do not edit by hand --><html lang="en" data-bs-theme="auto">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<title>Spatial Transcriptomics: All in One View</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="assets/themetoggle.js"></script><link rel="stylesheet" type="text/css" href="assets/styles.css">
<script src="assets/scripts.js" type="text/javascript"></script><!-- mathjax --><script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      config: ["MMLorHTML.js"],
      jax: ["input/TeX","input/MathML","output/HTML-CSS","output/NativeMML", "output/PreviewHTML"],
      extensions: ["tex2jax.js","mml2jax.js","MathMenu.js","MathZoom.js", "fast-preview.js", "AssistiveMML.js", "a11y/accessibility-menu.js"],
      TeX: {
        extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
      },
      tex2jax: {
        inlineMath: [['\\(', '\\)']],
        displayMath: [ ['$$','$$'], ['\\[', '\\]'] ],
        processEscapes: true
      }
    });
    </script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><!-- Responsive Favicon for The Carpentries --><link rel="apple-touch-icon" sizes="180x180" href="favicons/incubator/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="favicons/incubator/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="favicons/incubator/favicon-16x16.png">
<link rel="manifest" href="favicons/incubator/site.webmanifest">
<link rel="mask-icon" href="favicons/incubator/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="white">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="black">
</head>
<body>
    <header id="top" class="navbar navbar-expand-md top-nav incubator"><svg xmlns="http://www.w3.org/2000/svg" class="d-none"><symbol id="check2" viewbox="0 0 16 16"><path d="M13.854 3.646a.5.5 0 0 1 0 .708l-7 7a.5.5 0 0 1-.708 0l-3.5-3.5a.5.5 0 1 1 .708-.708L6.5 10.293l6.646-6.647a.5.5 0 0 1 .708 0z"></path></symbol><symbol id="circle-half" viewbox="0 0 16 16"><path d="M8 15A7 7 0 1 0 8 1v14zm0 1A8 8 0 1 1 8 0a8 8 0 0 1 0 16z"></path></symbol><symbol id="moon-stars-fill" viewbox="0 0 16 16"><path d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"></path><path d="M10.794 3.148a.217.217 0 0 1 .412 0l.387 1.162c.173.518.579.924 1.097 1.097l1.162.387a.217.217 0 0 1 0 .412l-1.162.387a1.734 1.734 0 0 0-1.097 1.097l-.387 1.162a.217.217 0 0 1-.412 0l-.387-1.162A1.734 1.734 0 0 0 9.31 6.593l-1.162-.387a.217.217 0 0 1 0-.412l1.162-.387a1.734 1.734 0 0 0 1.097-1.097l.387-1.162zM13.863.099a.145.145 0 0 1 .274 0l.258.774c.115.346.386.617.732.732l.774.258a.145.145 0 0 1 0 .274l-.774.258a1.156 1.156 0 0 0-.732.732l-.258.774a.145.145 0 0 1-.274 0l-.258-.774a1.156 1.156 0 0 0-.732-.732l-.774-.258a.145.145 0 0 1 0-.274l.774-.258c.346-.115.617-.386.732-.732L13.863.1z"></path></symbol><symbol id="sun-fill" viewbox="0 0 16 16"><path d="M8 12a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"></path></symbol></svg><a class="visually-hidden-focusable skip-link" href="#main-content">Skip to main content</a>
  <div class="container-fluid top-nav-container">
    <div class="col-md-8">
      <div class="large-logo">
        <img id="incubator-logo" alt="Carpentries Incubator" src="assets/images/incubator-logo.svg"><span class="badge text-bg-warning">
          <abbr title="This lesson is in the alpha phase, which means that it has been taught once and lesson authors are iterating on feedback.">
            <a href="https://cdh.carpentries.org/the-lesson-life-cycle.html#field-testing-alpha-stage" class="external-link alert-link">
              <i aria-hidden="true" class="icon" data-feather="alert-triangle" style="border-radius: 5px"></i>
              Alpha
            </a>
            <span class="visually-hidden">This lesson is in the alpha phase, which means that it has been taught once and lesson authors are iterating on feedback.</span>
          </abbr>
        </span>

      </div>
    </div>
    <div class="selector-container">
      <div id="theme-selector">
        <li class="nav-item dropdown" id="theme-button-list">
          <button class="btn btn-link nav-link px-0 px-lg-2 dropdown-toggle d-flex align-items-center" id="bd-theme" type="button" aria-expanded="false" data-bs-toggle="dropdown" data-bs-display="static" aria-label="Toggle theme (auto)">
            <svg class="bi my-1 theme-icon-active"><use href="#circle-half"></use></svg><i data-feather="chevron-down"></i>
          </button>
          <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="bd-theme-text">
<li>
              <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="light" aria-pressed="false">
                <svg class="bi me-2 theme-icon"><use href="#sun-fill"></use></svg>
                Light
                <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
            </li>
            <li>
              <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="dark" aria-pressed="false">
                <svg class="bi me-2 theme-icon"><use href="#moon-stars-fill"></use></svg>
                Dark
                <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
            </li>
            <li>
              <button type="button" class="btn dropdown-item d-flex align-items-center active" data-bs-theme-value="auto" aria-pressed="true">
                <svg class="bi me-2 theme-icon"><use href="#circle-half"></use></svg>
                Auto
                <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
            </li>
          </ul>
</li>
      </div>

      <div class="dropdown" id="instructor-dropdown">
        <button class="btn btn-secondary dropdown-toggle bordered-button" type="button" id="dropdownMenu1" data-bs-toggle="dropdown" aria-expanded="false">
          <i aria-hidden="true" class="icon" data-feather="eye"></i> Learner View <i data-feather="chevron-down"></i>
        </button>
        <ul class="dropdown-menu" aria-labelledby="dropdownMenu1">
<li><button class="dropdown-item" type="button" onclick="window.location.href='instructor/aio.html';">Instructor View</button></li>
        </ul>
</div>
    </div>
  </div>
  <hr></header><nav class="navbar navbar-expand-xl bottom-nav incubator" aria-label="Main Navigation"><div class="container-fluid nav-container">
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle Navigation">
      <span class="navbar-toggler-icon"></span>
      <span class="menu-title">Menu</span>
    </button>
    <div class="nav-logo">
      <img class="small-logo" alt="Carpentries Incubator" src="assets/images/incubator-logo-sm.svg">
</div>
    <div class="lesson-title-md">
      Spatial Transcriptomics
    </div>
    <div class="search-icon-sm">
      <!-- TODO: do not show until we have search
        <i role="img" aria-label="Search the All In One page" data-feather="search"></i>
      -->
    </div>
    <div class="desktop-nav">
      <ul class="navbar-nav me-auto mb-2 mb-lg-0">
<li class="nav-item">
          <span class="lesson-title">
            Spatial Transcriptomics
          </span>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="key-points.html">Key Points</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="reference.html#glossary">Glossary</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="profiles.html">Learner Profiles</a>
        </li>
        <li class="nav-item dropdown">
          <button class="nav-link dropdown-toggle" id="navbarDropdown" data-bs-toggle="dropdown" aria-expanded="false">
            More <i data-feather="chevron-down"></i>
          </button>
          <ul class="dropdown-menu" aria-labelledby="navbarDropdown">
<li><a class="dropdown-item" href="reference.html">Reference</a></li>
          </ul>
</li>
      </ul>
</div>
    <!--
    <form class="d-flex col-md-2 search-form">
      <fieldset disabled>
      <input class="form-control me-2 searchbox" type="search" placeholder="" aria-label="">
        <button class="btn btn-outline-success tablet-search-button"  type="submit">
          <i class="search-icon" data-feather="search" role="img" aria-label="Search the All In One page"></i>
        </button>
      </fieldset>
    </form>
    -->
    <a id="search-button" class="btn btn-primary" href="aio.html" role="button" aria-label="Search the All In One page">Search the All In One page</a>
  </div>
<!--/div.container-fluid -->
</nav><div class="col-md-12 mobile-title">
  Spatial Transcriptomics
</div>

<aside class="col-md-12 lesson-progress"><div style="width: %" class="percentage">
    %
  </div>
  <div class="progress incubator">
    <div class="progress-bar incubator" role="progressbar" style="width: %" aria-valuenow="" aria-label="Lesson Progress" aria-valuemin="0" aria-valuemax="100">
    </div>
  </div>
</aside><div class="container">
      <div class="row">
        <!-- START: inst/pkgdown/templates/navbar.html -->
<div id="sidebar-col" class="col-lg-4">
  <div id="sidebar" class="sidebar">
      <nav aria-labelledby="flush-headingEleven"><button role="button" aria-label="close menu" alt="close menu" aria-expanded="true" aria-controls="sidebar" class="collapse-toggle" data-collapse="Collapse " data-episodes="Episodes ">
          <i class="search-icon" data-feather="x" role="img"></i>
        </button>
        <div class="sidebar-inner">
          <div class="row mobile-row" id="theme-row-mobile">
            <div class="col" id="theme-selector">
              <li class="nav-item dropdown" id="theme-button-list">
                <button class="btn btn-link nav-link px-0 px-lg-2 dropdown-toggle d-flex align-items-center" id="bd-theme" type="button" aria-expanded="false" data-bs-toggle="dropdown" data-bs-display="static" aria-label="Toggle theme (auto)">
                  <svg class="bi my-1 theme-icon-active"><use href="#circle-half"></use></svg><span class="d-lg-none ms-1" id="bd-theme-text">Toggle Theme</span>
                </button>
                <ul class="dropdown-menu dropdown-menu-right" aria-labelledby="bd-theme-text">
<li>
                    <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="light" aria-pressed="false">
                      <svg class="bi me-2 theme-icon"><use href="#sun-fill"></use></svg>
                      Light
                      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
                  </li>
                  <li>
                    <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="dark" aria-pressed="false">
                      <svg class="bi me-2 theme-icon"><use href="#moon-stars-fill"></use></svg>
                      Dark
                      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
                  </li>
                  <li>
                    <button type="button" class="btn dropdown-item d-flex align-items-center active" data-bs-theme-value="auto" aria-pressed="true">
                      <svg class="bi me-2 theme-icon"><use href="#circle-half"></use></svg>
                      Auto
                      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
                  </li>
                </ul>
</li>
            </div>
          </div>
          <div class="row mobile-row">
            <div class="col">
              <div class="sidenav-view-selector">
                <div class="accordion accordion-flush" id="accordionFlush9">
                  <div class="accordion-item">
                    <h2 class="accordion-header" id="flush-headingNine">
                      <button class="accordion-button collapsed" id="instructor" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseNine" aria-expanded="false" aria-controls="flush-collapseNine">
                        <i id="eye" aria-hidden="true" class="icon" data-feather="eye"></i> Learner View
                      </button>
                    </h2>
                    <div id="flush-collapseNine" class="accordion-collapse collapse" aria-labelledby="flush-headingNine" data-bs-parent="#accordionFlush2">
                      <div class="accordion-body">
                        <a href="instructor/aio.html">Instructor View</a>
                      </div>
                    </div>
                  </div>
<!--/div.accordion-item-->
                </div>
<!--/div.accordion-flush-->
              </div>
<!--div.sidenav-view-selector -->
            </div>
<!--/div.col -->

            <hr>
</div>
<!--/div.mobile-row -->

          <div class="accordion accordion-flush" id="accordionFlush11">
            <div class="accordion-item">

              <button id="chapters" class="accordion-button show" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseEleven" aria-expanded="false" aria-controls="flush-collapseEleven">
                <h2 class="accordion-header chapters" id="flush-headingEleven">
                  EPISODES
                </h2>
              </button>
              <div id="flush-collapseEleven" class="accordion-collapse show collapse" aria-labelledby="flush-headingEleven" data-bs-parent="#accordionFlush11">

                <div class="accordion-body">
                  <div class="accordion accordion-flush" id="accordionFlush1">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading1">
        <a href="index.html">Summary and Setup</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush2">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading2">
        <a href="introduction.html">1. Spatially Resolved Transcriptomics in Life Sciences Research</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush3">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading3">
        <a href="data-and-study-design.html">2. Data and Study Design</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush4">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading4">
        <a href="data-preprocessing.html">3. Data Preprocessing</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush5">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading5">
        <a href="remove-low-quality-spots.html">4. Remove Low-quality Spots</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush6">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading6">
        <a href="apply-normalization-methods.html">5. Normalization in Spatial Transcriptomics</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush7">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading7">
        <a href="feature-selection-dimensionality-reduction-clustering.html">6. Feature Selection, Dimensionality Reduction, and Spot Clustering</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush8">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading8">
        <a href="deconvolve-cell-types-in-a-spot.html">7. Deconvolution in Spatial Transcriptomics</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush9">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading9">
        <a href="differential-expression-testing.html">8. Differential Expression Testing</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush10">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading10">
        <a href="final-exercise.html">9. Putting it all Together</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

                </div>
              </div>
            </div>

            <hr class="half-width">
<div class="accordion accordion-flush lesson-resources" id="accordionFlush12">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-headingTwelve">
                  <button class="accordion-button collapsed" id="lesson-resources" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseTwelve" aria-expanded="false" aria-controls="flush-collapseTwelve">
                    RESOURCES
                  </button>
                </h2>
                <div id="flush-collapseTwelve" class="accordion-collapse collapse" aria-labelledby="flush-headingTwelve" data-bs-parent="#accordionFlush12">
                  <div class="accordion-body">
                    <ul>
<li>
                        <a href="key-points.html">Key Points</a>
                      </li>
                      <li>
                        <a href="reference.html#glossary">Glossary</a>
                      </li>
                      <li>
                        <a href="profiles.html">Learner Profiles</a>
                      </li>
                      <li><a href="reference.html">Reference</a></li>
                    </ul>
</div>
                </div>
              </div>
            </div>
            <hr class="half-width lesson-resources">
<a href="aio.html">See all in one page</a>


            <hr class="d-none d-sm-block d-md-none">
<div class="d-grid gap-1">

            </div>
          </div>
<!-- /div.accordion -->
        </div>
<!-- /div.sidebar-inner -->
      </nav>
</div>
<!-- /div.sidebar -->
  </div>
<!-- /div.sidebar-col -->
<!-- END:   inst/pkgdown/templates/navbar.html-->

        <!-- START: inst/pkgdown/templates/content-extra.html -->
  <div class="col-xl-8 col-lg-12 primary-content">
    <main id="main-content" class="main-content"><div class="container lesson-content">
        
        
<section id="aio-introduction"><p>Content from <a href="introduction.html">Spatially Resolved Transcriptomics in Life Sciences Research</a></p>
<hr>
<p>Last updated on 2025-03-04 |

        <a href="https://github.com/smcclatchy/spatial-transcriptomics/edit/main/episodes/introduction.Rmd" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What is spatial transcriptomics?</li>
<li>What research questions or problems can spatial transcriptomics
address?</li>
<li>How do the technologies work?</li>
<li>Which technology will we learn about in this lesson?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Describe why and how spatial transcriptomics can be used in
research.</li>
<li>Describe how spatial transcriptomics technology works.</li>
<li>Describe how spatial transcriptomics addresses the limitations of
single-cell or bulk RNA sequencing technologies.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="spatial-transcriptomics-in-biomedical-research">Spatial transcriptomics in biomedical research<a class="anchor" aria-label="anchor" href="#spatial-transcriptomics-in-biomedical-research"></a>
</h2>
<hr class="half-width">
<p>Investigating the organization of cells and tissues is fundamental to
life sciences research. Cells and tissues situated in different regions
of an organ can possess diverse functions and cell types. These cells in
turn are influenced by varying tissue microenvironments, receiving and
processing distinct information from that microenvironment. Co-located
cells can communicate directly with one another through chemical and
mechanical signals, responding to these signals with changes in their
own state. Thus, knowing the spatial organization of cells in a tissue
can reveal cell and tissue function.</p>
<figure><img src="https://upload.wikimedia.org/wikipedia/commons/c/c3/Skeletal_muscle_-_cross_section%2C_nerve_bundle.jpg" alt="A cross-section of human skeletal muscle showing muscle cells and a nerve nearby. Stained with hematoxylin and eosin." class="figure mx-auto d-block"><div class="figcaption">A cross-section of skeletal muscle tissue
showing muscle cells and a small nerve.</div>
</figure><p><a href="https://commons.wikimedia.org/wiki/File:Skeletal_muscle_-_cross_section,_nerve_bundle.jpg" class="external-link">Department
of Histology, Jagiellonian University Medical College</a>
<a href="https://creativecommons.org/licenses/by-sa/3.0/deed.en" rel="license" class="external-link">CC
BY-SA 3.0 DEED</a></p>
<p>Spatially resolved transcriptomics describes spatial organization and
cell signals, specifically gene expression signals. Spatial patterns of
gene expression determine how genes are regulated within a tissue system
and how those tissues and their component cells function. Spatial
transcriptomic (ST) methods map cell position in a tissue, clarifying
the physical relationships between cells and cellular structures. ST
simultaneously measures gene expression, delivering valuable information
about cell phenotype, state, and cell and tissue organization and
function. The combination of cellular expression and position sheds
light on signals a cell sends or receives through cell-to-cell
interactions. Spatial information localizes cell signaling while
delivering comprehensive gene expression profiling within tissues.</p>
<figure><img src="https://upload.wikimedia.org/wikipedia/commons/0/04/Notchccr.svg" alt="alt text for accessibility purposes" class="figure mx-auto d-block"><div class="figcaption">Signaling between adjacent cells. The Notch
protein functions as a receptor for ligands that activate or inhibit
such receptors. Receptor-ligand interactions ground cell signaling and
communication, often requiring close proximity between cells.</div>
</figure><p><a href="https://commons.wikimedia.org/wiki/File:Notchccr.svg" class="external-link">Fred
the Oyster</a> Public domain, via Wikimedia Commons
<a href="https://creativecommons.org/licenses/by-sa/4.0/" rel="license" class="external-link">CC
BY-SA 4.0 DEED</a></p>
<p>Spatial transcriptomics addresses a key obstacle in single-cell and
bulk RNA sequencing studies: their loss of spatial information. Spatial
organization and structure determine function in most tissues and
organs, so capturing both spatial and expression information is critical
for understanding tissue function in neuroscience, immuno-oncology,
developmental biology, and most other fields.</p>
</section><section><h2 class="section-heading" id="spatial-transcriptomics-technologies">Spatial transcriptomics technologies<a class="anchor" aria-label="anchor" href="#spatial-transcriptomics-technologies"></a>
</h2>
<hr class="half-width">
<p>Spatial transcriptomics technologies broadly fall within two groups:
imaging-based and sequencing-based methods. Both imaging- and
sequence-based datasets are available through the <a href="https://biccn.org/" class="external-link">The BRAIN Initiative - Cell Census
Network</a>. Sequencing-based datasets are featured in the <a href="https://data.humancellatlas.org/" class="external-link">Human Cell Atlas</a>. These
technologies vary in ability to profile entire transcriptomes, deliver
single-cell resolution, and detect genes efficiently.</p>
<div class="section level3">
<h3 id="imaging-based-technologies">Imaging-based technologies<a class="anchor" aria-label="anchor" href="#imaging-based-technologies"></a>
</h3>
<p>Imaging-based technologies read transcriptomes in place using
microscopy at single-cell or even single-molecule resolution. They
identify messenger RNA (mRNA) species fluorescence in situ hybridization
(FISH), i.e., by hybridizing mRNA to gene-specific fluorescent
probes.</p>
<figure><img src="fig/FISH_Overview.png" alt="a general schematic showing fluorescence in situ hybridization" class="figure mx-auto d-block"><div class="figcaption">Overview of fluorescence in situ hybridization
(FISH).</div>
</figure><p><a href="https://commons.wikimedia.org/wiki/File:Spatial_Transcriptomics_Overview.png" class="external-link">
Adapted from Spatial Transcriptomics Overview by SlifertheRyeDragon.</a>
Image created with Biorender.com. Public domain, via Wikimedia Commons
<a href="https://creativecommons.org/licenses/by-sa/4.0/" rel="license" class="external-link">CC
BY-SA 4.0 DEED</a></p>
<p>RNA can be visualized in place in the original tissue environment by
hybridizing labeled probes to their specific targets. Current FISH
methods employ multiple hybridization rounds, with risk of error for
each transcript growing exponentially with each round. FISH methods are
limited in the size of tissue that they can profile and most are
applicable only to fresh-frozen (FF) tissue. They can also be
time-consuming and expensive due to microscopic imaging they require.
Since they target specific genes, they can only detect genes that are in
the probe set. They have high spatial resolution though, even delivering
single-molecule resolution in single-molecule FISH (smFISH). Even
technologies that can profile hundreds or thousands of mRNA transcripts
simultaneously, though, target throughput is low and spectral overlap of
fluorophores complicates microscopy.</p>
<p>Conventional FISH methods have few distinct color channels that limit
the number of genes that can be simultaneously analyzed. Multiplexed
error-robust FISH (MERFISH) overcomes this problem, greatly increasing
the number of RNA species that can be simultaneously imaged in single
cells by using binary code gene labeling in multiple rounds of
hybridization.</p>
<figure><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/ad/MERFISH_Diagram.png/1024px-MERFISH_Diagram.png" alt="alt text for accessibility purposes" class="figure mx-auto d-block"><div class="figcaption">Schematic representation of multiplexed
error-robust FISH (MERFISH). Binary codes assigned to mRNA species of
interest, where “1” represents a short fluorescent DNA probe. b,
Consecutive hybridization rounds, bleaching in between is implied, but
not shown for clarity. At the end of the sixth round, it is possible to
tell different mRNAs apart due to the decoded combinations of “1” and
“0”.</div>
</figure><p><a href="https://commons.wikimedia.org/wiki/File:MERFISH_Diagram.png" class="external-link">SlifertheRyeDragon</a>,
<a href="https://creativecommons.org/licenses/by-sa/4.0" class="external-link">CC BY-SA
4.0</a>, via Wikimedia Commons</p>
<p>A second imaging-based method, in situ sequencing, amplifies and
sequences mRNAs directly within a block or section of fresh-frozen (FF)
or formalin-fixed paraffin embedded (FFPE) tissue.</p>
<p><img src="fig/ISS_Overview.png" alt="a general schematic showing in situ sequencing" class="figure"><a href="https://commons.wikimedia.org/wiki/File:Spatial_Transcriptomics_Overview.png" class="external-link">
Adapted from Spatial Transcriptomics Overview by SlifertheRyeDragon.</a>
Image created with Biorender.com. Public domain, via Wikimedia Commons
<a href="https://creativecommons.org/licenses/by-sa/4.0/" rel="license" class="external-link">CC
BY-SA 4.0 DEED</a></p>
<p>Messenger RNA (mRNA) is reverse transcribed to complementary DNA
(cDNA) within tissue sections. A <em>padlock</em> probe binds to the
cDNA, which is then circularized. Following circularization, the cDNA is
amplified by rolling-circle amplification (RCA), then sequenced by
ligation for decoding. Probes profile one or two bases at a time using
different fluorophores, eventually revealing the identity of the cDNA
through imaging. Since it requires imaging, in situ sequencing is an
imaging-based method even though it involves sequencing. In situ
sequencing can accommodate larger tissue sections than can FISH, though
FISH methods are more efficient at detecting mRNA of genes in the probe
set. Like FISH, in situ sequencing requires considerable imaging time on
a microscope but delivers high spatial resolution. Both methods require
a priori knowledge of target mRNA.</p>
</div>
<div class="section level3">
<h3 id="sequencing-based-technologies">Sequencing-based technologies<a class="anchor" aria-label="anchor" href="#sequencing-based-technologies"></a>
</h3>
<p>Sequencing-based methods capture, sequence, and count mRNA using
next-generation sequencing while retaining positional information. This
is distinct from in situ sequencing because next-generation sequencing
is employed. Sequencing-based methods may be unbiased, in which they
capture the entire transcriptome, or probe-based, in which they
typically capture the majority of protein-coding genes. Sequencing-based
methods retain spatial information through laser-capture microdissection
(LCM), microfluidics, or through ligation of mRNAs to arrays of barcoded
probes that record position.</p>
<p>LCM-based methods employ lasers to cut a tissue slice or fuse tissue
to a membrane followed by sequencing of individual cells.</p>
<p><img src="fig/LCM_Overview.png" alt="a general schematic showing laser-capture microdissection " class="figure"><a href="https://commons.wikimedia.org/wiki/File:Spatial_Transcriptomics_Overview.png" class="external-link">
Adapted from Spatial Transcriptomics Overview by SlifertheRyeDragon.</a>
Image created with Biorender.com. Public domain, via Wikimedia Commons
<a href="https://creativecommons.org/licenses/by-sa/4.0/" rel="license" class="external-link">CC
BY-SA 4.0 DEED</a></p>
<p>LCM techniques process tissue sections for transcriptomic profiling
by isolating regions of interest. They are useful for profiling
transcriptomes as a first pass and for identifying RNA isoforms, but
their blunt approach to capturing spatial expression data limits spatial
resolution and requires many samples for sequencing. Since they focus on
regions of interest, it is difficult to grasp spatial expression across
a whole tissue. LCM is an older technology that has long been used with
FFPE tissues. Modern LCM-based approaches include Nanostring’s GeoMx DSP
and STRP-seq.</p>
<p>Microfluidics places a chip with multiple barcode-containing channels
onto a tissue section followed by a second chip with channels
perpendicular to the first. The barcodes are then ligated to each other
to create an array of unique barcodes on the tissue. This
<em>deterministic barcoding</em> is employed in DBiT-seq. DBiT-seq can
be used with FFPE tissues. This approach is helpful to avoid diffusion
of mRNA away from capture areas, though a disadvantage is that cells
often sit astride multiple capture areas.</p>
<p><img src="fig/Workflow-of-DBiT-seq-on-FFPE-samples-a-Scheme-of-DBiT-seq-on-FFPE-samples.png" alt="a general schematic showing a microfluidics workflow with DBit-seq on formalin-fixed paraffin embedded (FFPE) tissue" class="figure">
Adapted from
<a href="https://www.researchgate.net/publication/346261659_Spatial_transcriptome_sequencing_of_FFPE_tissues_at_cellular_level" class="external-link">Liu
Y, Enninful A, Deng Y, &amp; Fan R (2020). Spatial transcriptome
sequencing of FFPE tissues at cellular level. Preprint.</a>
<a href="https://creativecommons.org/licenses/by-sa/4.0/" rel="license" class="external-link">CC
BY-SA 4.0 DEED</a></p>
<p>Other array-based methods capture mRNA with spatially-barcoded probes
and sequence them. They can profile larger tissue sections than can FISH
or in situ sequencing and they don’t rely on time-consuming microscopic
imaging. Spatial resolution is lower, however.</p>
<p>In this lesson we will use data from positionally barcoded
arrays.</p>
<figure><img src="https://upload.wikimedia.org/wikipedia/commons/1/14/Spatial_transcriptomics_ii.png" alt="A graphic showing printed spots on a glass slide that are identified by a barcode and that contain primers to capture mRNA from the tissue laid on top of them" class="figure mx-auto d-block"><div class="figcaption">A sequencing-based spatial transcriptomics
method using printed spots on a slide.</div>
</figure><p><a href="https://commons.wikimedia.org/wiki/User:Jasquatch" class="external-link">James
Chell</a>,
<a href="https://commons.wikimedia.org/wiki/File:Spatial_transcriptomics_ii.png" class="external-link">Spatial
transcriptomics ii</a>,
<a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode" rel="license" class="external-link">CC
BY-SA 4.0</a></p>
<table class="table">
<colgroup>
<col width="27%">
<col width="18%">
<col width="18%">
<col width="18%">
<col width="18%">
</colgroup>
<thead><tr class="header">
<th>Technology</th>
<th align="center">Gene detection efficiency</th>
<th align="center">Transcriptome-wide profiling</th>
<th align="center">Spatial resolution</th>
<th align="center">Tissue area</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>FISH</td>
<td align="center">+</td>
<td align="center">-</td>
<td align="center">+</td>
<td align="center">-</td>
</tr>
<tr class="even">
<td>In situ sequencing</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="odd">
<td>LCM-based</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
<tr class="even">
<td>Microfluidics</td>
<td align="center">-</td>
<td align="center">+</td>
<td align="center">-</td>
<td align="center">+</td>
</tr>
<tr class="odd">
<td>Array-based</td>
<td align="center">-</td>
<td align="center">+</td>
<td align="center">-</td>
<td align="center">+</td>
</tr>
</tbody>
</table>
<p>Table 1. Relative strengths and weaknesses of spatial transcriptomics
technologies by general category.</p>
<div id="callout1" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Callout</h3>
<div class="callout-content">
<p>This introduction to the technologies is intended to help you
navigate a complex technological landscape so that you can learn more
about existing technologies. It is not intended to be comprehensive.</p>
</div>
</div>
</div>
<p>The diversity in spatial transcriptomics technologies is enormous and
rapidly developing. If you would like to learn more about spatial
transcriptomics technologies, please see the
<a href="./reference.html"><strong>list of references located
here</strong></a>.</p>
<div id="discussion-which-technology-is-right-for-your-research" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="discussion-which-technology-is-right-for-your-research" class="callout-inner">
<h3 class="callout-title">Discussion: Which technology is right for your research?</h3>
<div class="callout-content">
<ol style="list-style-type: decimal">
<li><p>Would an imaging-based or a sequencing-based solution be
preferable for your research? Why?</p></li>
<li><p>From the descriptions above, which technology do you think would
best suit your research? Would you use fresh-frozen (FF) or
formalin-fixed tissues embedded in paraffin (FFPE)? Even if your
institution does not offer service using a specific technology, describe
which best suits your research and why you think it’s best
suited.</p></li>
</ol>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" data-bs-parent="#accordionSolution1" aria-labelledby="headingSolution1">
<div class="accordion-body">
<p>Which technology you use depends on your experimental aim. If you are
testing hypotheses about specific genes, you can profile those genes at
high resolution and sensitivity with an imaging-based method. If instead
you aim to generate hypotheses, next generation sequencing-based methods
that profile many genes in an unbiased manner would be best.</p>
</div>
</div>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="x-genomics-visium-technology">10X Genomics Visium technology<a class="anchor" aria-label="anchor" href="#x-genomics-visium-technology"></a>
</h2>
<hr class="half-width">
<p>In this lesson we will use data from an array-based method called
Visium that is offered by <a href="https://www.10xgenomics.com/platforms/visium" class="external-link">10X Genomics</a>.
Visium is an upgrade and commercialization of the spatial
transcriptomics method described in 2016 in <a href="https://doi.org/10.1126/science.aaf2403" class="external-link">Science, 353(6294)</a>
and illustrated in general in the figure above. A more specific
schematic is given below.</p>
<figure><img src="fig/visium-technology.png" alt="a general schematic showing the Visium technology" class="figure mx-auto d-block"><div class="figcaption">Overview of Visium technology with fresh-frozen
(FF) or formalin-fixed paraffin embedded (FFPE) tissue. Source: <a href="https://www.10xgenomics.com/platforms/visium" class="external-link">10x Genomics
Visium</a>
</div>
</figure><p>Thin tissue sections are placed atop spots printed with spatial
barcodes. For fresh-frozen (FF) tissues, tissue fixing and
permeabilization discharges mRNA to bind with spatially barcoded probes
that indicate the position on the slide. The assay is sensitive to
permeabilization time, which is often optimized in a separate
experimental procedure. Captured mRNA is then reverse transcribed to
cDNA and sequencing libraries created from these. The formalin-fixed
paraffin embedded (FFPE) assay utilizes probe pairs that identify each
gene in the probe set and capture target genes by hybridizing to them.
Permeabilization discharges the captured mRNA to spatially barcoded
probes on the slide, but does not require a separate optimization step
as in the FF protocol. The capture mRNA is then extended to include
complements of the spatial barcodes. Sequencing libraries are then
formed from the captured and barcoded mRNA.</p>
<p>Spatial transcriptomics combines two key modes: histological imaging
and gene expression profiling. Histological imaging captures tissue
morphology with standard staining protocols while expression profiling
is captured by sequencing spatially barcoded cDNA.</p>
<p>Sequencing-based datasets have grown faster than have imaging-based
datasets, with Visium dominating published datasets. Unlike most other
sequencing-based technologies, Visium accommodates both FF or FFPE
tissue. Each spot provides average gene expression measurements from
between one to a few tens of cells, approaching single-cell resolution.
Average gene expression measurements are combined with histological
images that couple molecular detail and tissue morphology and
structure.</p>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>Spatial transcriptomics provides the location of cells relative to
neighboring cells and cell structures.</li>
<li>A cell’s location is useful data for describing its phenotype,
state, and cell and tissue function.</li>
<li>Spatial transcriptomics addresses a key obstacle in bulk and
single-cell RNA sequencing studies: their loss of spatial
information.</li>
<li>The main goal of spatial transcriptomics studies is to integrate
expression with spatial information.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-data-and-study-design"><p>Content from <a href="data-and-study-design.html">Data and Study Design</a></p>
<hr>
<p>Last updated on 2025-03-04 |

        <a href="https://github.com/smcclatchy/spatial-transcriptomics/edit/main/episodes/data-and-study-design.Rmd" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>Which data will we explore in this course?</li>
<li>How was the study that generated the data designed?</li>
<li>What are some critical design elements for rigorous, reproducible
spatial transcriptomics experiments?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Describe a spatial transcriptomics experiment.</li>
<li>Identify important elements for good experimental design.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="the-data">The Data<a class="anchor" aria-label="anchor" href="#the-data"></a>
</h2>
<hr class="half-width">
<p>Recall that tissue is laid on a glass slide containing spots with
primers to capture mRNA. The graphic below details a Visium slide with
four capture areas. Each capture area has arrays of barcoded spots
containing oligonucleotides. The oligonucleotides each contain a
poly(dT) sequence for capture of polyadenylated molecules, a unique
molecular identifier (UMI) to identify duplicate molecules, a spatial
barcode shared by all oligonucleotides within the same spot, and a
partial read for library preparation and sequencing.</p>
<figure><img src="fig/visium-slide.png" alt="A graphic showing printed spots on a glass slide that are identified by a barcode and that contain oligonucleotides to capture messenger RNA from the tissue laid on top of them" class="figure mx-auto d-block"><div class="figcaption">Visium spatial gene expression slide</div>
</figure><p>In spatial transcriptomics the barcode indicates the x-y coordinates
of the spot. Barcodes are generic identifiers that identify different
things in different technologies. A barcode in single-cell
transcriptomics, for example, refers to a single cell, not to a spot on
a slide. When you see barcodes in ST data, think <em>spot</em>, not
<em>single cell</em>. In fact, one spot can capture mRNA from many
cells. This is a feature of ST experiments that is distinct from
single-cell transcriptomics experiments. As a result, many single-cell
methods won’t work with ST data. Later we will look at methods to <a href="deconvolve-cell-types-in-a-spot.html"><em>deconvolve</em> cell
types per spot</a> to determine the number and types of cells in each
spot. Spots can contain zero, one, or many cells.</p>
<p>The graphic below shows a Visium workflow for fresh-frozen
tissues.</p>
<p><img src="fig/fresh-frozen-workflow.png" alt="A Visium spatial transcriptomics workflow with fresh-frozen tissue" class="figure">
Graphic from
<a href="https://www.10xgenomics.com/library/6f2b8a" class="external-link"><i>Grant
application resources for Visium products</i></a> at 10X Genomics</p>
<p>Count data for each mRNA are mapped back to spots on the slide to
indicate the tissue position of gene expression. An image of the tissue
overlaid on the array of spots pinpoints spatial gene expression in the
tissue.</p>
<figure><img src="fig/Spatial_transcriptomics_ii_lower_third.png" alt="A graphic showing printed spots on a glass slide that are identified by a barcode and that contain primers to capture messenger RNA from the tissue laid on top of them" class="figure mx-auto d-block"><div class="figcaption">Sequencing data is mapped back to spots on the
slide and compared to an image of the tissue to localize
expression</div>
</figure><p>Adapted from
<a href="https://commons.wikimedia.org/wiki/User:Jasquatch" class="external-link">James
Chell</a>,
<a href="https://commons.wikimedia.org/wiki/File:Spatial_transcriptomics_ii.png" class="external-link">Spatial
transcriptomics ii</a>,
<a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode" rel="license" class="external-link">CC
BY-SA 4.0</a></p>
<p>Data from the 10X Genomics Visium platform contain gene identifiers
in rows and barcode identifiers in columns. In the graphic below, row 1
of column 1 contains the mRNA counts for gene 1 at barcode (spot) 1.</p>
<figure><img src="fig/spatial-data.png" alt="An example of spatial transcriptomics data showing genes in rows and barcodes (spots) in columns" class="figure mx-auto d-block"><div class="figcaption">Spatial transcriptomics data include genes in
rows and barcodes in columns</div>
</figure><div id="challenge-1-row-and-column-sums" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-1-row-and-column-sums" class="callout-inner">
<h3 class="callout-title">Challenge 1: Row and column sums</h3>
<div class="callout-content">
<p>What does the sum of a single row signify?<br>
What does the sum of a single column signify?</p>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" data-bs-parent="#accordionSolution1" aria-labelledby="headingSolution1">
<div class="accordion-body">
<p>The row sum is the total expression of one gene across all spots on
the slide.</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">sum</span><span class="op">(</span><span class="st">'data[1, ]'</span><span class="op">)</span></span></code></pre>
</div>
<p>The column sum is the total expression of all genes for one spot on
the slide.</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">sum</span><span class="op">(</span><span class="st">'data[ , 1]'</span><span class="op">)</span></span></code></pre>
</div>
</div>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="design-and-motivation-of-prefrontal-cortext-study">Design and Motivation of Prefrontal Cortext Study<a class="anchor" aria-label="anchor" href="#design-and-motivation-of-prefrontal-cortext-study"></a>
</h2>
<hr class="half-width">
<p>We will use data from a study of the human prefrontal cortex
published in <a href="https://doi.org/10.1038/s41593-020-00787-0" class="external-link">Transcriptome-scale
spatial gene expression in the human dorsolateral prefrontal cortex by
Maynard et al, Nat Neurosci 24, 425–436 (2021).</a> This region of the
brain, involved in higher-order cognition and managing thoughts and
actions in conformance with internal goals, is particularly amenable to
spatial analyses because its structure is intimately tied to its
function. Specifically, the six cortical layers and the white matter
shown below are comprised of cells with distinct gene expression
profiles and differing patterns of morphology, physiology, and
connectivity.</p>
<figure><img src="fig/tissue-block-with-layers.png" alt="A human brain showing a section of dorsolateral prefrontal cortex extracted. A block of tissue containing six cortical layers and an underlying layer of white matter is excised from the section." class="figure mx-auto d-block"><div class="figcaption">Tissue blocks were excised from human
dorsolateral prefrontal cortex. Tissue blocks include six cortical
layers and underlying white matter (wm).</div>
</figure><p>Adapted from
<a href="https://doi.org/10.1038/s41593-020-00787-0" class="external-link">Maynard et al, Nat
Neurosci 24, 425–436 (2021)</a>.
<a href="https://www.biorender.com" class="external-link">Created with BioRender.com</a>.</p>
<p>The dorsolateral prefrontal cortex is implicated in some
neuropsychiatric disorders such as autism spectrum disorder (ASD) and
schizophrenia disorder (SCZD), and differences in gene expression and
pathology are located in specific cortical layers. Localizing gene
expression at cellular resolution within the six layers can illuminate
disease mechanisms and brain development. As such, the authors aimed to
map gene expression to the spatial organization of the six cortical
layers. This course will largely follow their analyses in defining the
gene expression markers of the cortical layers.</p>
<p>Spatial transcriptomics has several advantages relative to other
technologies in meeting the authors’ objective. Owing to their large
size and fragility, human neurons are difficult to isolate with
scRNA-seq. This has motivated the use of single-nucleus(sn)RNA-seq in
most studies. Unfortunately, this modality fails to capture cytoplasmic
compartments of the cell, as well as axons and dendrites, and the genes
within these regions have been associated with SCZD and ASD. Laser
capture microdissection followed by sequencing does capture all cellular
compartments, but can not be use to detect spatial gradients of gene
expression since it removes tissues from their spatial context. Spatial
transcriptomics offers the ability both to capture the entire repertoire
of cells resident in the brain and to establish the expression gradient
across them within the spatial context of the intact tissue.</p>
<p>The authors proceeded in their spatial transcriptomics study by
selecting wwo pairs of spatially adjacent replicates from three
neurotypical donors. The second pair of replicates was taken from 300
microns posterior to the first pair of replicates.</p>
<p><img src="fig/experimental-design.png" alt="Three Visium slides showing four spatial capture areas each. Each slide contains directly adjacent serial tissue sections for one subject. The second pair of samples contains tissue sections that are 300 microns posterior to the first pair of samples." class="figure">
Adapted from
<a href="https://doi.org/10.1038/s41593-020-00787-0" class="external-link">Maynard et al, Nat
Neurosci 24, 425–436 (2021)</a>.
<a href="https://www.biorender.com" class="external-link">Created with BioRender.com</a>.</p>
<div id="challenge-2-what-do-you-notice" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-2-what-do-you-notice" class="callout-inner">
<h3 class="callout-title">Challenge 2: What do you notice?</h3>
<div class="callout-content">
<p>What do you notice about the experimental design that might create
issues during data analysis? Why might the authors have done the
experiment this way? Is there anything that can be done about this?</p>
</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2"> Show me the solution </h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" data-bs-parent="#accordionSolution2" aria-labelledby="headingSolution2">
<div class="accordion-body">
<p>Human brain tissues start to deteriorate at death. Brain banks that
provide tissue for studies requiring intact mRNA will quickly remove the
brain and rapidly weigh, examine, dissect and freeze it to optimize mRNA
integrity. For this study, dorsolateral prefrontal cortex samples were
embedded in a medium (see Methods section) and then cryosectioned.
Sections were then placed on chilled Visium slides, fixed and
stained.</p>
<p>This whole process might have depended on donor availability. All
three donors were neurotypical, and it’s not clear how they died
(<em>e.g.</em>, an accident, a terminal illness, old age) and how that
might have impacted availability or mRNA quality. Suffice it to say that
it might not have been possible to predict when samples would be
available, so it might not have been possible to randomize the samples
from each donor to different Visium slides.</p>
<p>Sometimes you might have to confound variables in your study due to
sample availability or other factors. The key thing is to know that
confounding has occurred.</p>
</div>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="important-considerations-for-rigorous-reproducible-experiments">Important considerations for rigorous, reproducible experiments<a class="anchor" aria-label="anchor" href="#important-considerations-for-rigorous-reproducible-experiments"></a>
</h2>
<hr class="half-width">
<p>Good experimental design plays a critical role in obtaining reliable
and meaningful results and is an essential feature of rigorous,
reproducible experiments. Designed experiments aim to describe and
explain variability under experimental conditions. Variability is
natural in the real world. A medication given to a group of patients
will affect each of them differently. A specific diet given to a cage of
mice will affect each mouse differently. Ideally if something is
measured many times, each measurement will give exactly the same result
and will represent the true value. This ideal doesn’t exist in the real
world. Variability is a feature of natural systems and also a natural
part of every experiment we undertake.</p>
<div class="section level4">
<h4 id="replication">Replication<a class="anchor" aria-label="anchor" href="#replication"></a>
</h4>
<p>To figure out whether a difference in responses is real or inherently
random, replication applies the same treatment to multiple experimental
units. The variability of the responses within a set of replicates
provides a measure against which we can compare differences among
different treatments. <em>Experimental error</em> describes the
variability in the responses. Random variation (a.k.a random error or
noise) reflects imprecision, but not inaccuracy. Larger sample sizes
reduce this imprecision.</p>
<p>In addition to random (experimental) error, systematic error or bias
occurs when there are deviations in measurements or observations that
consistently either overestimate or underestimate the true value. As an
example, a scale might be calibrated so that mass measurements are
consistently too high or too low. Unlike random error, systematic error
is consistent in one direction, is predictable and follows a pattern.
Larger sample sizes don’t correct for systematic bias; equipment or
measurement calibration does. Technical replicates define this
systematic bias by running the same sample through the machine or
measurement protocol multiple times to characterize the variation caused
by equipment or protocols.</p>
<p>A biological replicate measures different biological samples in
parallel to estimate the variation caused by the unique biology of the
samples. The sample or group of samples are derived from the same
biological source, such as cells, tissues, organisms, or individuals.
Biological replicates assess the variability and reproducibility of
experimental results. The greater the number of biological replicates,
the greater the precision (the closeness of two or more measurements to
each other). Having a large enough sample size to ensure high precision
is necessary to ensure reproducible results. Note that increasing the
number of technical replicates will not help to characterize biological
variability! It is used to characterize systematic error, not
experimental error.</p>
<div id="challenge-3-which-kind-of-error" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-3-which-kind-of-error" class="callout-inner">
<h3 class="callout-title">Challenge 3: Which kind of error?</h3>
<div class="callout-content">
<p>A study used to determine the effect of a drug on weight loss could
have the following sources of experimental error. Classify the following
sources as either biological, systematic, or random error.<br>
1). A scale is broken and provides inconsistent readings.<br>
2). A scale is calibrated wrongly and consistently measures mice 1 gram
heavier.<br>
3). A mouse has an unusually high weight compared to its experimental
group (<em>e.g.</em>, it is an outlier).<br>
4). Strong atmospheric low pressure and accompanying storms affect
instrument readings, animal behavior, and indoor relative humidity.</p>
</div>
</div>
</div>
<div id="accordionSolution3" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution3" aria-expanded="false" aria-controls="collapseSolution3">
  <h4 class="accordion-header" id="headingSolution3"> Solution to Challenge 3 </h4>
</button>
<div id="collapseSolution3" class="accordion-collapse collapse" data-bs-parent="#accordionSolution3" aria-labelledby="headingSolution3">
<div class="accordion-body">
<p>1). random, because the scale is broken and provides any kind of
random reading it comes up with (inconsistent reading)<br>
2). systematic<br>
3). biological<br>
4). random or systematic; you argue which and explain why</p>
</div>
</div>
</div>
</div>
<div id="challenge-4-how-many-technical-and-biological-replicates" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-4-how-many-technical-and-biological-replicates" class="callout-inner">
<h3 class="callout-title">Challenge 4: How many technical and biological replicates?</h3>
<div class="callout-content">
<p>In each scenario described below, identify how many technical and how
many biological replicates are represented. What conclusions can be
drawn about experimental error in each scenario?</p>
<p>1). One person is weighed on a scale five times.<br>
2). Five people are weighed on a scale one time each.<br>
3). Five people are weighed on a scale three times each.<br>
4). A cell line is equally divided into four samples. Two samples
receive a drug treatment, and the other two samples receive a different
treatment. The response of each sample is measured three times to
produce twelve total observations. In addition to the number of
replicates, can you identify how many experimental units there
are?<br>
5). A cell line is equally divided into two samples. One sample receives
a drug treatment, and the other sample receives a different treatment.
Each sample is then further divided into two subsamples, each of which
is measured three times to produce twelve total observations. In
addition to the number of replicates, can you identify how many
experimental units there are?</p>
</div>
</div>
</div>
<div id="accordionSolution4" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution4" aria-expanded="false" aria-controls="collapseSolution4">
  <h4 class="accordion-header" id="headingSolution4"> Solution to Challenge 4 </h4>
</button>
<div id="collapseSolution4" class="accordion-collapse collapse" data-bs-parent="#accordionSolution4" aria-labelledby="headingSolution4">
<div class="accordion-body">
<p>1). One biological sample (not replicated) with five technical
replicates. The only conclusion to be drawn from the measurements would
be better characterization of systematic error in measuring. It would
help to describe variation produced by the instrument itself, the scale.
The measurements would not generalize to other people.<br>
2). Five biological replicates with one technical measurement (not
replicated). The conclusion would be a single snapshot of the weight of
each person, which would not capture systematic error or variation in
measurement of the scale. There are five biological replicates, which
would increase precision, however, there is considerable other variation
that is unaccounted for.<br>
3). Five biological replicates with three technical replicates each. The
three technical replicates would help to characterize systematic error,
while the five biological replicates would help to characterize
biological variability.<br>
4). Four biological replicates with three technical replicates each. The
three technical replicates would help to characterize systematic error,
while the four biological replicates would help to characterize
biological variability. Since the treatments are applied to each of the
four samples, there are four experimental units.<br>
5). Two biological replicates with three technical replicates each.
Since the treatments are applied to only the two original samples, there
are only two experimental units.</p>
</div>
</div>
</div>
</div>
</div>
<div class="section level4">
<h4 id="randomization">Randomization<a class="anchor" aria-label="anchor" href="#randomization"></a>
</h4>
<p>Randomization minimizes bias, moderates experimental error (a.k.a.
noise), and ensures that our comparisons between treatment groups are
valid. Randomized studies assign experimental units to treatment groups
randomly by pulling a number out of a hat or using a computer’s random
number generator. The main purpose for randomization comes later during
statistical analysis, where we compare the data we have with the data
distribution we might have obtained by random chance. Random assignment
(<em>allocation</em>) of experimental units to treatment groups prevents
the subjective bias that might be introduced by an experimenter who
selects, even in good faith and with good intention, which experimental
units should get which treatment.</p>
<p>Randomization also accounts for or cancels out effects of “nuisance”
variables like the time or day of the experiment, the investigator or
technician, equipment calibration, exposure to light or ventilation in
animal rooms, or other variables that are not being studied but that do
influence the responses. Randomization balances out the effects of
nuisance variables between treatment groups by giving an equal
probability for an experimental unit to be assigned to any treatment
group.</p>
<div id="challenge-5-treatment-and-control-samples" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-5-treatment-and-control-samples" class="callout-inner">
<h3 class="callout-title">Challenge 5: Treatment and control samples</h3>
<div class="callout-content">
<p>You plan to place samples of treated tissue on one slide and samples
of the controls on another slide. What will happen when it is time for
data analysis? What could you have done differently? <img src="fig/treated-and-control-slides.png" alt="An experiment with treated samples on one slide and control samples on another." class="figure"></p>
</div>
</div>
</div>
<div id="accordionSolution5" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution5" aria-expanded="false" aria-controls="collapseSolution5">
  <h4 class="accordion-header" id="headingSolution5"> Show me the solution </h4>
</button>
<div id="collapseSolution5" class="accordion-collapse collapse" data-bs-parent="#accordionSolution5" aria-labelledby="headingSolution5">
<div class="accordion-body">

</div>
</div>
</div>
</div>
<div id="challenge-6-time-points" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-6-time-points" class="callout-inner">
<h3 class="callout-title">Challenge 6: Time points</h3>
<div class="callout-content">
<p>Your study requires data collection at three time points: 5, 10, and
15 weeks. At the end of 5 weeks, you will run samples through the entire
Visium workflow. You will repeat this for the 10- and 15-week samples
when each of those time points is reached. What will happen when it is
time for data analysis? What could you have done differently?</p>
<figure><img src="fig/timepoints.png" alt="An experiment with three timepoints at 5, 10 and 15 weeks. At the end of the first 5 weeks, those samples are run through Visium. This is repeated at 10 and 15 weeks." class="figure mx-auto d-block"><div class="figcaption">Three time points in an experiment</div>
</figure>
</div>
</div>
</div>
<div id="accordionSolution6" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution6" aria-expanded="false" aria-controls="collapseSolution6">
  <h4 class="accordion-header" id="headingSolution6"> Show me the solution </h4>
</button>
<div id="collapseSolution6" class="accordion-collapse collapse" data-bs-parent="#accordionSolution6" aria-labelledby="headingSolution6">
<div class="accordion-body">
<p>The issue is that time point is now confounded. A better approach
would be to start the 15-week samples, then 5 weeks later start the
10-week samples, then 5 weeks later start the 5-week samples. This way
you can run all of your samples at the same time. None of your samples
will have spent a long time in the freezer, so you won’t need to worry
about the variation that might cause. You won’t need to worry about the
time point confounding the results.</p>
</div>
</div>
</div>
</div>
<div id="challenge-7-the-efficient-technician" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-7-the-efficient-technician" class="callout-inner">
<h3 class="callout-title">Challenge 7: The efficient technician</h3>
<div class="callout-content">
<p>Your technician colleague finds a way to simplify and expedite an
experiment. The experiment applies four different wheel-running
treatments to twenty different mice over the course of five days. Four
mice are treated individually each day for two hours each with a random
selection of the four treatments. Your clever colleague decides that a
simplified protocol would work just as well and save time. Run treatment
1 five times on day 1, treatment 2 five times on day 2, and so on. Some
overtime would be required each day but the experiment would be
completed in only four days, and then they can take Friday off! Does
this adjustment make sense to you?<br>
Can you foresee any problems with the experimental results?</p>
<figure><img src="fig/wheel-running-experiment.png" alt="Four different wheel running treatments applied to 5 mice each. Treatment 1 is applied on day 1, treatment 2 on day 2, and so on." class="figure mx-auto d-block"><div class="figcaption">Four different wheel running treatments each
applied once per day to five mice, for a total of 20 mice treated.</div>
</figure>
</div>
</div>
</div>
<div id="accordionSolution7" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution7" aria-expanded="false" aria-controls="collapseSolution7">
  <h4 class="accordion-header" id="headingSolution7"> Solution to Challenge 6 </h4>
</button>
<div id="collapseSolution7" class="accordion-collapse collapse" data-bs-parent="#accordionSolution7" aria-labelledby="headingSolution7">
<div class="accordion-body">
<p>Since each treatment is run on only one day, the day effectively
becomes the experimental unit (explain this). Each experimental unit
(day) has five samples (mice), but only one replication of each
treatment. There is no valid way to compare treatments as a result.
There is no way to separate the treatment effect from the day-to-day
differences in environment, equipment setup, personnel, and other
extraneous variables.</p>
</div>
</div>
</div>
</div>
</div>
<div class="section level4">
<h4 id="statistical-power">Statistical power<a class="anchor" aria-label="anchor" href="#statistical-power"></a>
</h4>
<p>Statistical power represents the probability of detecting a real
treatment effect. Review the following figure to explore the
relationships between effect size, sample size, and power. What is the
relationship between effect size and sample size? Between sample size
and power?</p>
<figure><img src="fig/data-and-study-design-rendered-power-curve-2-1.png" style="display: block; margin: auto;" class="figure mx-auto d-block"></figure><p>Adapted from <a href="https://levibaguley.github.io/2020/06/22/how-to-create-power-curves-in-ggplot/" class="external-link">How
to Create Power Curves in ggplot</a> by Levi Baguley</p>
<p>Notice that to detect a standardized effect size of 0.5 at 80% power,
you would need a sample size of approximately 70. Larger effect sizes
require much smaller sample sizes. Very small effects such as .01 never
reach the 80% power threshold without enormous samples sizes in the
hundreds of thousands.</p>
<figure><img src="fig/Null-hypothesis.png" alt="A normal curve with a mean of zero showing the type 1 error rate in the far right tail and specificity in the left of the curve." class="figure mx-auto d-block"><div class="figcaption">The null hypothesis states that there is no
difference between treatment groups.</div>
</figure><figure><img src="fig/Alternative-hypothesis.png" alt="A normal curve with a mean of approximately 3 showing the type 2 error rate in the left of the curve and sensitivity (also known as statistical power) in the far right tail of the curve. The effect size is shown as the difference in means between the null and alternative hypotheses." class="figure mx-auto d-block"><div class="figcaption">The alternative hypothesis states that there is
a difference between treatment groups.</div>
</figure><p>The effect size is shown in the figure above as the difference in
means between the null and alternative hypotheses. Statistical power,
also known as sensitivity, is the power to detect this effect.</p>
<p>To learn more about statistical power, effect sizes and sample size
calculations, see <a href="https://www.nature.com/articles/nmeth.2738" class="external-link">Power and sample size
by Krzywinski &amp; Altman</a> , Nature Methods 10, pages 1139–1140
(2013).</p>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>Use <code>.md</code> files for episodes when you want static
content</li>
<li>Use <code>.Rmd</code> files for episodes when you need to generate
output</li>
<li>Run <code>sandpaper::check_lesson()</code> to identify any issues
with your lesson</li>
<li>Run <code>sandpaper::build_lesson()</code> to preview your lesson
locally</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div>
</section></section><section id="aio-data-preprocessing"><p>Content from <a href="data-preprocessing.html">Data Preprocessing</a></p>
<hr>
<p>Last updated on 2025-03-04 |

        <a href="https://github.com/smcclatchy/spatial-transcriptomics/edit/main/episodes/data-preprocessing.Rmd" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What data files should I expect from the Visium assay?</li>
<li>Which data preprocessing steps are required to prepare the raw data
files for further analysis?</li>
<li>What software will we use for data preprocessing?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Explain how to use markdown with the new lesson template</li>
<li>Demonstrate how to include pieces of code, figures, and nested
challenge blocks</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<hr class="half-width">
<p>The <a href="https://www.10xgenomics.com/support/software/space-ranger" class="external-link"><code>Space Ranger</code></a>
software is a popular, though by no means only, set of pipelines for
preprocessing of Visium data. We focus on it here. It provides the
following output:</p>
<table class="table">
<colgroup>
<col width="48%">
<col width="52%">
</colgroup>
<thead><tr class="header">
<th>File Name</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>web_summary.html</td>
<td>Run summary metrics and plots in HTML format</td>
</tr>
<tr class="even">
<td>cloupe.cloupe</td>
<td>Loupe Browser visualization and analysis file</td>
</tr>
<tr class="odd">
<td>spatial/</td>
<td>Folder containing outputs that capture the spatiality of the
data.</td>
</tr>
<tr class="even">
<td>spatial/aligned_fiducials.jpg</td>
<td>Aligned fiducials QC image</td>
</tr>
<tr class="odd">
<td>spatial/aligned_tissue_image.jpg</td>
<td>Aligned CytAssist and Microscope QC image. Present only for
CytAssist workflow</td>
</tr>
<tr class="even">
<td>spatial/barcode_fluorescence_intensity.csv</td>
<td>CSV file containing the mean and standard deviation of fluorescence
intensity for each spot and each channel. Present for the fluorescence
image input specified by –darkimage</td>
</tr>
<tr class="odd">
<td>spatial/cytassist_image.tiff</td>
<td>Input CytAssist image in original resolution that can be used to
re-run the pipeline. Present only for CytAssist workflow</td>
</tr>
<tr class="even">
<td>spatial/detected_tissue_image.jpg</td>
<td>Detected tissue QC image.</td>
</tr>
<tr class="odd">
<td>spatial/scalefactors_json.json</td>
<td>Scale conversion factors for spot diameter and coordinates at
various image resolutions</td>
</tr>
<tr class="even">
<td>spatial/spatial_enrichment.csv</td>
<td>Feature spatial autocorrelation analysis using Moran’s I in CSV
format</td>
</tr>
<tr class="odd">
<td>spatial/tissue_hires_image.png</td>
<td>Downsampled full resolution image. The image dimensions depend on
the input image and slide version</td>
</tr>
<tr class="even">
<td>spatial/tissue_lowres_image.png</td>
<td>Full resolution image downsampled to 600 pixels on the longest
dimension</td>
</tr>
<tr class="odd">
<td>spatial/tissue_positions.csv</td>
<td>CSV containing spot barcode; if the spot was called under (1) or out
(0) of tissue, the array position, image pixel position x, and image
pixel position y for the full resolution image</td>
</tr>
<tr class="even">
<td>analysis/</td>
<td>Folder containing secondary analysis data including graph-based
clustering and K-means clustering (K = 2-10); differential gene
expression between clusters; PCA, t-SNE, and UMAP dimensionality
reduction.</td>
</tr>
<tr class="odd">
<td>metrics_summary.csv</td>
<td>Run summary metrics in CSV format</td>
</tr>
<tr class="even">
<td>probe_set.csv</td>
<td>Copy of the input probe set reference CSV file. Present for Visium
FFPE and CytAssist workflow</td>
</tr>
<tr class="odd">
<td>possorted_genome_bam.bam</td>
<td>Indexed BAM file containing position-sorted reads aligned to the
genome and transcriptome, annotated with barcode information</td>
</tr>
<tr class="even">
<td>possorted_genome_bam.bam.bai</td>
<td>Index for possorted_genome_bam.bam. In cases where the reference
transcriptome is generated from a genome with very long chromosomes
(&gt;512 Mbp), Space Ranger v2.0+ generates a
possorted_genome_bam.bam.csi index file instead.</td>
</tr>
<tr class="odd">
<td>filtered_feature_bc_matrix/</td>
<td>Contains only tissue-associated barcodes in MEX format. Each element
of the matrix is the number of UMIs associated with a feature (row) and
a barcode (column). This file can be input into third-party packages and
allows users to wrangle the barcode-feature matrix (<em>e.g.</em> to
filter outlier spots, run dimensionality reduction, normalize gene
expression).</td>
</tr>
<tr class="even">
<td><strong>filtered_feature_bc_matrix.h5</strong></td>
<td><strong>Same information as filtered_feature_bc_matrix/ but in HDF5
format.</strong></td>
</tr>
<tr class="odd">
<td>raw_feature_bc_matrices/</td>
<td>Contains all detected barcodes in MEX format. Each element of the
matrix is the number of UMIs associated with a feature (row) and a
barcode (column).</td>
</tr>
<tr class="even">
<td><strong>raw_feature_bc_matrix.h5</strong></td>
<td><strong>Same information as raw_feature_bc_matrices/ in HDF5
format.</strong></td>
</tr>
<tr class="odd">
<td>﻿</td>
<td>raw_probe_bc_matrix.h5</td>
</tr>
<tr class="even">
<td>molecule_info.h5</td>
<td>Contains per-molecule information for all molecules that contain a
valid barcode, valid UMI, and were assigned with high confidence to a
gene or protein barcode. This file is required for additional analysis
spaceranger pipelines including aggr, targeted-compare and
targeted-depth.</td>
</tr>
</tbody>
</table>
<p>Fortunately, you will not need to look at all of these files. We
provide a brief description for you in case you are curious or need to
look at one of the files for technical reasons.</p>
<p>The two files that you will use are
<code>raw_feature_bc_matrix.h5</code> and
<code>filtered_feature_bc_matrix.h5</code>. These files have an
<code>h5</code> suffix, which means that they are HDF5 files. <a href="https://www.hdfgroup.org/solutions/hdf5/" class="external-link"><code>HDF5</code></a> is
a compressed file format for storing complex high-dimensional data. HDF5
stands for <em>Hierarchical Data Formats, version 5</em>. There is an R
package designed to read and write HDF5 files called <a href="https://bioconductor.org/packages/release/bioc/html/rhdf5.html" class="external-link"><code>rhdf5</code></a>.
This was one of the packages which you installed during the lesson
setup.</p>
<p>Briefly, <code>HDF5</code> organizes data into directories within the
compressed file. There are three “files” within the <code>HDF5</code>
file:</p>
<table class="table">
<colgroup>
<col width="53%">
<col width="46%">
</colgroup>
<thead><tr class="header">
<th>File Name</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>features.csv</td>
<td>Contains the features (<em>i.e.</em> genes in this case) for each
row in the data matrix.</td>
</tr>
<tr class="even">
<td>barcodes.csv</td>
<td>Contains the probe barcodes for each spot on the tissue block.</td>
</tr>
<tr class="odd">
<td>matrix.mtx</td>
<td>Contains the counts for each gene in each spot. Features
(<em>e.g.</em> genes) are in rows and barcodes (<em>e.g.</em> spots) are
in columns.</td>
</tr>
</tbody>
</table></section><section><h2 class="section-heading" id="set-up-environment">Set up Environment<a class="anchor" aria-label="anchor" href="#set-up-environment"></a>
</h2>
<hr class="half-width">
<p>Go to the <code>File</code> menu and select
<code>Open Project</code>. Open the <code>spatialRNA</code> project
which you created in the workshop setup.</p>
<p>First, we will load in some utility functions to make our lives a bit
easier. The <a href="https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/source" class="external-link"><code>source</code></a>
function reads an R file and runs the code in it. In this case, this
will load several useful functions.</p>
<p>We will then load the libraries that we need for this lesson.</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">suppressPackageStartupMessages</span><span class="op">(</span><span class="kw">library</span><span class="op">(</span><span class="va">tidyverse</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu">suppressPackageStartupMessages</span><span class="op">(</span><span class="kw">library</span><span class="op">(</span><span class="va">hdf5r</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu">suppressPackageStartupMessages</span><span class="op">(</span><span class="kw">library</span><span class="op">(</span><span class="va">Seurat</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="kw">source</span><span class="op">(</span><span class="st">"https://raw.githubusercontent.com/smcclatchy/spatial-transcriptomics/main/code/spatial_utils.R"</span><span class="op">)</span></span></code></pre>
</div>
</section><section><h2 class="section-heading" id="load-raw-and-filtered-spatial-expression-data">Load Raw and Filtered Spatial Expression Data<a class="anchor" aria-label="anchor" href="#load-raw-and-filtered-spatial-expression-data"></a>
</h2>
<hr class="half-width">
<p>In this course, we will use the <a href="https://satijalab.org/seurat/" class="external-link">Seurat</a> R environment, which was
originally designed for analysis of single-cell RNA-seq data, but has
been extended for spatial transcriptomics data. The Seurat website
provides helpful <a href="https://satijalab.org/seurat/articles/get_started_v5_new" class="external-link">vignettes</a>
and a concise command <a href="https://satijalab.org/seurat/articles/essential_commands" class="external-link">cheat
sheet</a>. <a href="https://bioconductor.org/packages/release/bioc/html/SpatialExperiment.html" class="external-link"><code>SpatialExperiment</code></a>
in R and <a href="https://scanpy.readthedocs.io/en/stable/" class="external-link"><code>scanpy</code></a>
in python, amongst others, are also frequently used in analyzing spatial
transcriptomics data.</p>
<p>We will use the <a href="https://www.rdocumentation.org/packages/Seurat/versions/5.0.1/topics/Load10X_Spatial" class="external-link"><code>Load10X_Spatial</code></a>
function from Seurat to read in the spatial transcriptomics data. These
are the data which you downloaded in the setup section.</p>
<p>First, we will read in the raw data for sample 151673.</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">raw_st</span> <span class="op">&lt;-</span> <span class="fu">Load10X_Spatial</span><span class="op">(</span>data.dir      <span class="op">=</span> <span class="st">"./data/151673"</span>, </span>
<span>                          filename      <span class="op">=</span> <span class="st">"151673_raw_feature_bc_matrix.h5"</span>,</span>
<span>                          filter.matrix <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></code></pre>
</div>
<p>If you did not see any error messages, then the data loaded in and
you should see an <code>raw_st</code> object in your
<code>Environment</code> tab on the right.</p>

<p>Let’s look at <code>raw_st</code>, which is a Seurat object.</p>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">raw_st</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>An object of class Seurat
33538 features across 4992 samples within 1 assay
Active assay: Spatial (33538 features, 0 variable features)
 1 layer present: counts
 1 spatial field of view present: slice1</code></pre>
</div>
<p>The output says that we have 33,538 <em>features</em> and 4,992
<em>samples</em> with one assay. <em>Feature</em> is a generic term for
anything that we measured. In this case, we measured gene expression, so
each feature is a gene. Each <em>sample</em> is one spot on the spatial
slide. So this tissue sample has 33,538 genes assayed across 4,992
spots.</p>
<p>An experiment may have more than one <em>assay</em>. For example, you
may run both RNA sequencing and chromatin accessibility in the same set
of samples. In this case, we have one assay – RNA-seq. Each assay will,
in turn, have one or more <em>layers</em>. Each layer stores a different
form of the data. Initially, our Seurat object has a single
<em>counts</em> layer, holding the raw, un-normalized RNA-seq counts for
each spot. Subsequent downstream analyses can populate other layers,
including normalized counts (conventionally stored in a <em>data</em>
layer) or variance-stabilized counts (conventionally stored in a
<em>scale.data</em> layer).</p>
<p>There is also a single image called <em>slice1</em> attached to the
Seurat object.</p>
<p>Next, we will load in the filtered data. Use the code above and look
in a file browser to identify the <code>filtered</code> file for sample
151673.</p>
<div id="challenge-1-read-in-filtered-hdf5-file-for-sample-151673." class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-1-read-in-filtered-hdf5-file-for-sample-151673." class="callout-inner">
<h3 class="callout-title">Challenge 1: Read in filtered HDF5 file for sample 151673.</h3>
<div class="callout-content">
<p>Open a file browser and navigate to
<code>Desktop/spatialRNA/data/151673</code>. Can you find an HDF5 file
(with an <code>.h5</code> suffix) that has the word “filtered” in
it?</p>
<p>If so, read that file in and assign it to a variable called
<code>filter_st</code>.</p>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Solution 1 </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" data-bs-parent="#accordionSolution1" aria-labelledby="headingSolution1">
<div class="accordion-body">
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">filter_st</span> <span class="op">&lt;-</span> <span class="fu">Load10X_Spatial</span><span class="op">(</span>data.dir <span class="op">=</span> <span class="st">"./data/151673"</span>, </span>
<span>                             filename <span class="op">=</span> <span class="st">"151673_filtered_feature_bc_matrix.h5"</span><span class="op">)</span></span></code></pre>
</div>
</div>
</div>
</div>
</div>
<p>Once you have the filtered data loaded in, look at the object.</p>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">filter_st</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>An object of class Seurat
33538 features across 3639 samples within 1 assay
Active assay: Spatial (33538 features, 0 variable features)
 1 layer present: counts
 1 spatial field of view present: slice1</code></pre>
</div>
<p>The raw and filtered data both have the same number of genes
(33,538). But the two objects have different numbers of spots. The raw
data has 4,992 spots and the filtered data has 3,639 spots.</p>
<p>Look at the H&amp;E slide below and notice the grey <em>fiducial</em>
spots around the border. These are used by the spatial transcriptomics
software to <em>register</em> the H&amp;E image and the
spatially-barcoded sequences.</p>
<figure><img src="fig/tissue_hires_image_151673.png" alt="H &amp; E slide of sample 151673" class="figure mx-auto d-block"><div class="figcaption">H &amp; E slide of sample 151673</div>
</figure><div id="challenge-2-how-does-the-computer-know-how-to-orient-the-image" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-2-how-does-the-computer-know-how-to-orient-the-image" class="callout-inner">
<h3 class="callout-title">Challenge 2: How does the computer know how to orient the image?</h3>
<div class="callout-content">
<p>Look carefully at the spots in the H&amp;E image above. Are the spots
symmetric? Is there anything different about the spots that might help a
computer to assign up/down and left/right to the image?</p>
</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2"> Solution 2 </h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" data-bs-parent="#accordionSolution2" aria-labelledby="headingSolution2">
<div class="accordion-body">
<p>Look at the spots in each corner. In the upper-left, you will see the
following patterns:</p>
<figure><img src="fig/tissue_diagram_with_registration_spots.png" alt="Diagram showing tissue and registration spots in corners" class="figure mx-auto d-block"><div class="figcaption">Slide Diagram</div>
</figure><p>The patterns in each corner allow the spatial transcriptomics
software to orient the slide.</p>
</div>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="add-spot-metadata">Add Spot Metadata<a class="anchor" aria-label="anchor" href="#add-spot-metadata"></a>
</h2>
<hr class="half-width">
<p>The 10x Space Ranger pipeline automatically segments the tissue to
identify it within the background of the slide. This information is
encoded in the “tissue positions” file. Each row in the file corresponds
to a spot. The first column indicates whether the spot was (1) or was
not (0) identified as being within the tissue region by the segmentation
procedure. This file does not contain column names in earlier versions
of Space Ranger, but does starting with version <a href="https://www.10xgenomics.com/support/software/space-ranger/latest/analysis/outputs/spatial-outputs" class="external-link"><code>SpaceRanger 2.0</code></a>.</p>
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">tissue_position</span> <span class="op">&lt;-</span> <span class="fu">read_csv</span><span class="op">(</span><span class="st">"./data/151673/spatial/tissue_positions_list.csv"</span>,</span>
<span>                            col_names <span class="op">=</span> <span class="cn">FALSE</span>, show_col_types <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span> <span class="op">%&gt;%</span> </span>
<span>                     <span class="fu">column_to_rownames</span><span class="op">(</span><span class="st">'X1'</span><span class="op">)</span></span>
<span><span class="fu">colnames</span><span class="op">(</span><span class="va">tissue_position</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu">c</span><span class="op">(</span><span class="st">"in_tissue"</span>, </span>
<span>                               <span class="st">"array_row"</span>, </span>
<span>                               <span class="st">"array_col"</span>, </span>
<span>                               <span class="st">"pxl_row_in_fullres"</span>, </span>
<span>                               <span class="st">"pxl_col_in_fullres"</span><span class="op">)</span></span></code></pre>
</div>
<p>It is important to note that the order of the spots differs between
the Seurat object and the tissue position file. We need to reorder the
tissue positions to match the Seurat object. We can extract the spot
barcodes using the <a href="https://satijalab.org/seurat/reference/cells" class="external-link"><code>Cells</code></a>
function. This is named for the earlier versions of Seurat, which
processed single cell transcriptomic data. In this case, we are getting
<strong>spot</strong> IDs, even though the function is called
<code>Cells</code>.</p>
<p>Next, we will add the tissue positions to the Seurat object’s
metadata. Note that Seurat will align the spot barcodes in this
process.</p>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">raw_st</span>    <span class="op">&lt;-</span> <span class="fu">AddMetaData</span><span class="op">(</span>object <span class="op">=</span> <span class="va">raw_st</span>,    metadata <span class="op">=</span> <span class="va">tissue_position</span><span class="op">)</span></span>
<span><span class="va">filter_st</span> <span class="op">&lt;-</span> <span class="fu">AddMetaData</span><span class="op">(</span>object <span class="op">=</span> <span class="va">filter_st</span>, metadata <span class="op">=</span> <span class="va">tissue_position</span><span class="op">)</span></span></code></pre>
</div>
<p>Next, we will plot the spot annotation, indicating spots that are in
the tissue in blue and background spots in red.</p>
<div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">SpatialPlot</span><span class="op">(</span><span class="va">raw_st</span>, group.by <span class="op">=</span> <span class="st">"in_tissue"</span>, alpha <span class="op">=</span> <span class="fl">0.3</span><span class="op">)</span></span></code></pre>
</div>
<figure style="text-align: center"><img src="fig/data-preprocessing-rendered-unnamed-chunk-8-1.png" alt="Histology slide with tissue and background spots labelled" class="figure mx-auto d-block"><figcaption>
Spots identified in Tissue and Background
</figcaption></figure><p>The 10x platform tags each molecule with a Unique Molecular
Identifier (UMI). This allows us to keep only one unique sequencing read
per molecule and to exclude those arising from PCR duplication. We
expect most of the UMI counts to be in the tissue spots. The Seurat
object metadata contains the UMI count in each spot in a column called
<code>nCount_Spatial</code>. Let’s plot the UMI counts in the tissue and
background spots.</p>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">raw_st</span><span class="op">@</span><span class="va">meta.data</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">ggplot</span><span class="op">(</span><span class="fu">aes</span><span class="op">(</span><span class="fu">as.logical</span><span class="op">(</span><span class="va">in_tissue</span><span class="op">)</span>, <span class="va">nCount_Spatial</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span></span>
<span>    <span class="fu">geom_boxplot</span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>    <span class="fu">labs</span><span class="op">(</span>title <span class="op">=</span> <span class="st">'UMI Counts in Tissue and Background'</span>,</span>
<span>         x     <span class="op">=</span> <span class="st">'In Tissue?'</span>,</span>
<span>         y     <span class="op">=</span> <span class="st">'Counts'</span><span class="op">)</span></span></code></pre>
</div>
<figure style="text-align: center"><img src="fig/data-preprocessing-rendered-unnamed-chunk-9-1.png" alt="Boxplot showing lower trancript counts in background area of slide" class="figure mx-auto d-block"><figcaption>
UMI Counts in Tissue and Background
</figcaption></figure><p>As expected, we see most of the counts in the tissue spots.</p>
<p>We can also plot the number of genes detected in each spot. Seurat
calls genes <em>features</em>, so we will plot the
<code>nFeature_Spatial</code> value. This is stored in the metadata of
the Seurat object.</p>
<div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">raw_st</span><span class="op">@</span><span class="va">meta.data</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">ggplot</span><span class="op">(</span><span class="fu">aes</span><span class="op">(</span><span class="fu">as.logical</span><span class="op">(</span><span class="va">in_tissue</span><span class="op">)</span>, <span class="va">nFeature_Spatial</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span></span>
<span>    <span class="fu">geom_boxplot</span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>    <span class="fu">labs</span><span class="op">(</span>title <span class="op">=</span> <span class="st">'Number of Genes in Tissue and Background'</span>,</span>
<span>         x     <span class="op">=</span> <span class="st">'In Tissue?'</span>,</span>
<span>         y     <span class="op">=</span> <span class="st">'Number of Genes'</span><span class="op">)</span></span></code></pre>
</div>
<figure style="text-align: center"><img src="fig/data-preprocessing-rendered-unnamed-chunk-10-1.png" alt="Boxplot showing lower numbers of genes in background area of slide" class="figure mx-auto d-block"><figcaption>
Number of Genes in Tissue and Background
</figcaption></figure><div id="challenge-3-why-might-there-be-umi-counts-outside-of-the-tissue-boundaries" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-3-why-might-there-be-umi-counts-outside-of-the-tissue-boundaries" class="callout-inner">
<h3 class="callout-title">Challenge 3: Why might there be UMI counts outside of the tissue boundaries?</h3>
<div class="callout-content">
<p>We expect UMI counts in the spots which overlap with the tissue
section. What reasons can you think of that might lead UMI counts to
occur in the background spots?</p>
</div>
</div>
</div>
<div id="accordionSolution3" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution3" aria-expanded="false" aria-controls="collapseSolution3">
  <h4 class="accordion-header" id="headingSolution3"> Solution 3 </h4>
</button>
<div id="collapseSolution3" class="accordion-collapse collapse" data-bs-parent="#accordionSolution3" aria-labelledby="headingSolution3">
<div class="accordion-body">
<ol style="list-style-type: decimal">
<li>When the tissue section is lysed, some transcripts may leak out of
the cells and into the background region of the slide.</li>
</ol>
</div>
</div>
</div>
</div>
<p>Up to this point, we have been working with the raw, unfiltered data
to show you how the spots are filtered. However, in most workflows, you
will work directly with the filtered file. From this point forward, we
will work with the filtered data object.</p>
<p>Let’s plot the spots in the tissue in the filtered object to verify
that it is only using spots in the tissue.</p>
<div class="codewrapper sourceCode" id="cb13">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">plot1</span> <span class="op">&lt;-</span> <span class="fu">SpatialDimPlot</span><span class="op">(</span><span class="va">filter_st</span>, alpha <span class="op">=</span> <span class="fu">c</span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span> </span>
<span>           <span class="fu">NoLegend</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">plot2</span> <span class="op">&lt;-</span> <span class="fu">SpatialDimPlot</span><span class="op">(</span><span class="va">filter_st</span><span class="op">)</span> <span class="op">+</span> </span>
<span>           <span class="fu">NoLegend</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">plot1</span> <span class="op">|</span> <span class="va">plot2</span></span></code></pre>
</div>
<figure><img src="fig/data-preprocessing-rendered-unnamed-chunk-11-1.png" style="display: block; margin: auto;" class="figure mx-auto d-block"></figure></section><section><h2 class="section-heading" id="plot-umi-and-gene-counts-across-tissue">Plot UMI and Gene Counts across Tissue<a class="anchor" aria-label="anchor" href="#plot-umi-and-gene-counts-across-tissue"></a>
</h2>
<hr class="half-width">
<p>Next, we want to look at the distribution of UMI counts and numbers
of genes in each spot across the tissue. This can be helpful in
identifying technical issues with the sample processing.</p>
<p>It is useful to first think about what we expect. In the publication
associated with this data, the authors show the structure that they
expect in this tissue section of the human dorsolateral prefrontal
cortex (DLPFC). In the figure below, they show a series of layers, from
L1 to L6, arranged from the upper right to the lower left. In the lower
left corner, they expect to see <em>White Matter</em> (WM). So we expect
to see some series of layers arranged from the upper right to the lower
left.</p>
<!-- ![Maynard et al, Figure 1c](fig/Maynard_etal_Fig1c.png){alt="Figure 1c"} -->
<p>We will use Seurat’s <a href="https://satijalab.org/seurat/reference/spatialplot" class="external-link"><code>SpatialFeaturePlot</code></a>
function to look at these values. We can color the spots based on the
spot metadata stored in the Seurat object. You can find these column
names by looking at the <code>meta.data</code> slot of the Seurat
object.</p>
<div class="codewrapper sourceCode" id="cb14">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">head</span><span class="op">(</span><span class="va">filter_st</span><span class="op">@</span><span class="va">meta.data</span><span class="op">)</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>                      orig.ident nCount_Spatial nFeature_Spatial in_tissue
AAACAAGTATCTCCCA-1 SeuratProject           8458             3586         1
AAACAATCTACTAGCA-1 SeuratProject           1667             1150         1
AAACACCAATAACTGC-1 SeuratProject           3769             1960         1
AAACAGAGCGACTCCT-1 SeuratProject           5433             2424         1
AAACAGCTTTCAGAAG-1 SeuratProject           4278             2264         1
AAACAGGGTCTATATT-1 SeuratProject           4004             2178         1
                   array_row array_col pxl_row_in_fullres pxl_col_in_fullres
AAACAAGTATCTCCCA-1        50       102               8468               9791
AAACAATCTACTAGCA-1         3        43               2807               5769
AAACACCAATAACTGC-1        59        19               9505               4068
AAACAGAGCGACTCCT-1        14        94               4151               9271
AAACAGCTTTCAGAAG-1        43         9               7583               3393
AAACAGGGTCTATATT-1        47        13               8064               3665</code></pre>
</div>
<p>To plot the UMI counts, we will use the <code>nCount_Spatial</code>
column in the spot metadata.</p>
<div class="codewrapper sourceCode" id="cb16">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">plot1</span> <span class="op">&lt;-</span> <span class="fu">SpatialDimPlot</span><span class="op">(</span><span class="va">filter_st</span>, alpha <span class="op">=</span> <span class="fu">c</span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span> </span>
<span>           <span class="fu">NoLegend</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">plot2</span> <span class="op">&lt;-</span> <span class="fu">SpatialFeaturePlot</span><span class="op">(</span><span class="va">filter_st</span>, features <span class="op">=</span> <span class="st">"nCount_Spatial"</span><span class="op">)</span></span>
<span><span class="va">plot1</span> <span class="op">|</span> <span class="va">plot2</span></span></code></pre>
</div>
<figure style="text-align: center"><img src="fig/data-preprocessing-rendered-unnamed-chunk-13-1.png" alt="Figure showing UMI counts in each spot with varying intensity across the tissue" class="figure mx-auto d-block"><figcaption>
UMI Counts in each Spot
</figcaption></figure><p>In this case, we see a band of higher counts running from upper left
to lower right. There are also bands of lower counts above and below
this band. The band in the upper right corner may be due to the fissure
in the tissue. It is less clear why the expression is low in the
lower-left corner.</p>
<p>We can also look at the number of genes detected in each spot using
<code>nFeature_Spatial</code>.</p>
<div class="codewrapper sourceCode" id="cb17">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">plot1</span> <span class="op">&lt;-</span> <span class="fu">SpatialDimPlot</span><span class="op">(</span><span class="va">filter_st</span>, alpha <span class="op">=</span> <span class="fu">c</span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span> </span>
<span>           <span class="fu">NoLegend</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">plot2</span> <span class="op">&lt;-</span> <span class="fu">SpatialFeaturePlot</span><span class="op">(</span><span class="va">filter_st</span>, features <span class="op">=</span> <span class="st">"nFeature_Spatial"</span><span class="op">)</span></span>
<span><span class="va">plot1</span> <span class="op">|</span> <span class="va">plot2</span></span></code></pre>
</div>
<figure style="text-align: center"><img src="fig/data-preprocessing-rendered-unnamed-chunk-14-1.png" alt="Figure showing number of genes detected in each spot with varying intensity across the tissue" class="figure mx-auto d-block"><figcaption>
Number of Genes in each Spot
</figcaption></figure><p>It is difficult to lay out a broad set of rules that will work for
all types of tissues and samples. Some tissues may have homogeneous UMI
counts across the section, while others may show variation in UMI counts
due to tissue structure. For example, in cancer tissue sections, stromal
cells tend to have lower counts than tumor cells and this should be
evident in a UMI count plot. In the brain sample below, we might expect
some variation in UMI counts in different layers of the brain.</p>
</section><section><h2 class="section-heading" id="removing-genes-with-low-expression">Removing Genes with Low Expression<a class="anchor" aria-label="anchor" href="#removing-genes-with-low-expression"></a>
</h2>
<hr class="half-width">
<p>In order to build this lesson, we needed to reduce the size of the
data. To do this, we are going to filter out genes that have no
expression across the cells.</p>
<p>How many genes to we have before filtering?</p>
<div class="codewrapper sourceCode" id="cb18">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">paste</span><span class="op">(</span><span class="fu">nrow</span><span class="op">(</span><span class="va">filter_st</span><span class="op">)</span>, <span class="st">"genes."</span><span class="op">)</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>[1] "33538 genes."</code></pre>
</div>
<p>Next, we will get the raw counts, calculate the sum of each gene’s
exprsssion across all spots, and filter the Seurat object to retain
genes with summed counts greater than zero.</p>
<div class="codewrapper sourceCode" id="cb20">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">counts</span>     <span class="op">&lt;-</span> <span class="fu">LayerData</span><span class="op">(</span><span class="va">filter_st</span>, <span class="st">'counts'</span><span class="op">)</span></span>
<span><span class="va">gene_sums</span>  <span class="op">&lt;-</span> <span class="fu">rowSums</span><span class="op">(</span><span class="va">counts</span><span class="op">)</span></span>
<span><span class="va">keep_genes</span> <span class="op">&lt;-</span> <span class="fu">which</span><span class="op">(</span><span class="va">gene_sums</span> <span class="op">&gt;</span> <span class="fl">0</span><span class="op">)</span></span>
<span></span>
<span><span class="va">filter_st</span>  <span class="op">&lt;-</span> <span class="va">filter_st</span><span class="op">[</span><span class="va">keep_genes</span>,<span class="op">]</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">WARNING<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="warning" tabindex="0"><code>Warning: Not validating Centroids objects
Not validating Centroids objects</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">WARNING<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="warning" tabindex="0"><code>Warning: Not validating FOV objects
Not validating FOV objects
Not validating FOV objects
Not validating FOV objects
Not validating FOV objects
Not validating FOV objects</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">WARNING<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="warning" tabindex="0"><code>Warning: Not validating Seurat objects</code></pre>
</div>
<p>How many genes to we have after filtering?</p>
<div class="codewrapper sourceCode" id="cb24">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">paste</span><span class="op">(</span><span class="fu">nrow</span><span class="op">(</span><span class="va">filter_st</span><span class="op">)</span>, <span class="st">"genes."</span><span class="op">)</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>[1] "21842 genes."</code></pre>
</div>
<p>So we removed about 11,700 genes that had zero counts.</p>
</section><section><h2 class="section-heading" id="conclusion">Conclusion<a class="anchor" aria-label="anchor" href="#conclusion"></a>
</h2>
<hr class="half-width">
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>The 10x Space Ranger pipeline provides you with an unfiltered and a
filtered data file.</li>
<li>The HDF5 file ends with an <code>h5</code> extension and contains
the barcodes, features (genes), and counts matrix.</li>
<li>Seurat is one of several popular environments for analyzing spatial
transcriptomics data.</li>
<li>It is important to know something about the structure of the tissue
which you are analyzing.</li>
<li>Plotting total counts and genes in each spot may help to identify
quality control issues.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-remove-low-quality-spots"><p>Content from <a href="remove-low-quality-spots.html">Remove Low-quality Spots</a></p>
<hr>
<p>Last updated on 2025-03-04 |

        <a href="https://github.com/smcclatchy/spatial-transcriptomics/edit/main/episodes/remove-low-quality-spots.Rmd" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>How do I remove low-quality spots?</li>
<li>What kinds of problems produce low-quality spots?</li>
<li>What happens if I skip quality control and proceed with
analysis?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Understand how to look for low quality spots.</li>
<li>Decide whether to retain or remove low quality spots.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<hr class="half-width">
<p>Spatial transcriptomics involves a complex process that may involve
some technical failures. If the processing of the entire slide fails, it
should be obvious due to a large number of gene appearing in spots
outside of the tissue or low UMIs across the whole tissue.</p>
<p>However, there can also be variation in spot quality in a slide that
has largely high-quality spots. These artifacts are much rarer than in
single-cell transcriptomics because the process of tissue sectioning is
less disruptive than tissue dissociation. Because of this, we recommend
light spot filtering.</p>
<p>There are three metrics that we will use to identify and remove
low-quality spots:</p>
<ol style="list-style-type: decimal">
<li>Mitochondrial gene expression,</li>
<li>Total UMI counts,</li>
<li>Number of detected genes.</li>
</ol>
<p>During tissue processing, it is possible that some cells will be
lysed, spilling out the transcripts, but retaining the mitochondria.
These spots will appear with much higher mitochondrial gene expression.
High UMI counts or number of detected genes might also indicate spots
with bleed over of lysed content from neighboring cells.</p>
<p>There may be regions of the slide with artifacts introduced during
slide preparation. These include tearing and folding of the tissue. As
mentioned above, the 10x Space Ranger pipeline automatically segments
the tissue boundary. This generally performs well at a large scale.
However, at high resolution, it may fail to properly assign spots within
small tears or along the jagged edge to the background. Such spots might
be identified by low UMI counts or number of detected genes. Conversely,
folded tissue may have a higher density of cells, which could result in
high UMI counts or number of detected genes. Pathologist annotation of
H&amp;E image can flag artifactual regions that are then excluded from
downstream analysis. Image processing techniques may also be able to
automatically identify and exclude artifactual regions, particularly
folds. Using pathologist annotation or image processing to identify
tissue abnormalities is less common than using the simple data-driven
metrics considered here, and we do not discuss them further.</p>
<p>These metrics may be tissue-dependent. In some tissues, there may be
biological reasons for differential expression across the tissue. For
example, in a cancer sample, mitochondrial or total gene expression may
vary between stromal and tumor regions. It will be important for you to
familiarize yourself with the structure of the tissue that you are
analyzing in order to make rational judgments about filtering.</p>
</section><section><h2 class="section-heading" id="filtering-by-mitochondrial-gene-count">Filtering by Mitochondrial Gene Count<a class="anchor" aria-label="anchor" href="#filtering-by-mitochondrial-gene-count"></a>
</h2>
<hr class="half-width">
<p>In single-cell RNA sequencing experiments, the tissue is digested and
the cells are dissociated. This mechanical disruption is stressful to
the cells and some of them are damaged in the process. Elevated levels
of mitochondrial genes often indicate cell death or damage because, when
a cell’s membrane is compromised, it loses most cytoplasmic content
while retaining mitochondrial RNA. Therefore, spots with high
mitochondrial RNA may represent damaged or dying cells, and their
exclusion helps focus the analysis on healthy, intact cells.</p>
<p>More details on this relationship can be found in the <a href="https://genomebiology.biomedcentral.com/articles/10.1186/s13059-016-0888-1" class="external-link">literature
on mitochondrial DNA and cell death</a>.</p>
<p>However, in spatial transcriptomics, the tissue is either frozen or
formalin-fixed and there is much less mechanical disruption of the
tissue. Because of this, we are skeptical of the value of filtering
spots based on mitochondrial gene counts.</p>
<p>For completeness, we show how to obtain the mitochondrial genes,
calculate the percentage of counts produced by these genes in each spot,
and add this to the Seurat object metadata.</p>
<p>We will search the gene symbols in the feature metadata to identify
mitochondrial genes. We do not need to find all genes in these
categories, so we will search for genes with symbols that start with
“MT”.</p>
<p>The Seurat object is designed to be flexible and may contains several
data types. For example, it may contain both gene counts and open
chromatin peaks. In this analysis, the Seurat object only contains gene
counts. The different types of data are called “Layers” in Seurat and
may be accessed using the <a href="https://satijalab.github.io/seurat-object/reference/Layers.html" class="external-link">Layers</a>
function.</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">Layers</span><span class="op">(</span><span class="va">filter_st</span><span class="op">)</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>[1] "counts"</code></pre>
</div>
<p>This tells us that the “filter_st” object only contains one data
Layer called “counts”. We can access this using the <a href="https://satijalab.github.io/seurat-object/reference/Layers.html" class="external-link">LayerData</a>
function using “counts” as an argument.</p>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">counts</span> <span class="op">&lt;-</span> <span class="fu">LayerData</span><span class="op">(</span><span class="va">filter_st</span>, <span class="st">'counts'</span><span class="op">)</span></span>
<span><span class="fu">head</span><span class="op">(</span><span class="va">counts</span><span class="op">)</span><span class="op">[</span>,<span class="fl">1</span><span class="op">:</span><span class="fl">5</span><span class="op">]</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>6 x 5 sparse Matrix of class "dgCMatrix"
            AAACAAGTATCTCCCA-1 AAACAATCTACTAGCA-1 AAACACCAATAACTGC-1
MIR1302-2HG                  .                  .                  .
AL627309.1                   .                  .                  .
AL669831.5                   .                  .                  .
FAM87B                       .                  .                  .
LINC00115                    .                  .                  .
FAM41C                       .                  .                  .
            AAACAGAGCGACTCCT-1 AAACAGCTTTCAGAAG-1
MIR1302-2HG                  .                  .
AL627309.1                   .                  .
AL669831.5                   .                  .
FAM87B                       .                  .
LINC00115                    .                  .
FAM41C                       .                  .</code></pre>
</div>
<p>The output above may look odd to you since there are no numbers.
Notice that the text above the table says “sparse Matrix”. Many of the
counts in the file are likely to be zero. Due to the manner in which
numbers are stored in computer memory, a zero takes up as much space as
a number. If we had to store all of these zeros, it would consume a lot
of computer memory. A sparse matrix is a special data structure which
only stores the non-zero values. In the table above, each dot (.)
represents a position with zero counts.</p>

<p>If we look at another part of the “counts” matrix, we can see
numbers.</p>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">counts</span><span class="op">[</span><span class="fl">20000</span><span class="op">:</span><span class="fl">20005</span>,<span class="fl">1</span><span class="op">:</span><span class="fl">5</span><span class="op">]</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>6 x 5 sparse Matrix of class "dgCMatrix"
       AAACAAGTATCTCCCA-1 AAACAATCTACTAGCA-1 AAACACCAATAACTGC-1
DNAJB1                  .                  .                  .
TECR                    3                  1                  .
NDUFB7                  3                  1                  1
ZNF333                  .                  .                  .
ADGRE2                  .                  .                  .
OR7C1                   .                  .                  .
       AAACAGAGCGACTCCT-1 AAACAGCTTTCAGAAG-1
DNAJB1                  1                  .
TECR                    2                  1
NDUFB7                  2                  4
ZNF333                  .                  .
ADGRE2                  .                  .
OR7C1                   .                  .</code></pre>
</div>
<p>As you can see in the table above, the gene symbols are stored in the
rownames of “counts”. We will find find mitochondrial genes by searching
for gene symbols which start with “MT”.</p>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">mito_pattern</span> <span class="op">&lt;-</span> <span class="st">'^[Mm][Tt]-'</span></span>
<span><span class="va">mito_genes</span>   <span class="op">&lt;-</span> <span class="fu">rownames</span><span class="op">(</span><span class="va">counts</span><span class="op">)</span><span class="op">[</span><span class="fu">grep</span><span class="op">(</span><span class="va">mito_pattern</span>, <span class="fu">rownames</span><span class="op">(</span><span class="va">counts</span><span class="op">)</span><span class="op">)</span><span class="op">]</span></span>
<span><span class="va">mito_genes</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code> [1] "MT-ND1"  "MT-ND2"  "MT-CO1"  "MT-CO2"  "MT-ATP8" "MT-ATP6" "MT-CO3"
 [8] "MT-ND3"  "MT-ND4L" "MT-ND4"  "MT-ND5"  "MT-ND6"  "MT-CYB" </code></pre>
</div>
<p>We now have a set of mitochondrial genes. We will use these genes to
estimate the percentage of gene counts expressed by mitochondrial genes
in each cell and add this to the Seurat object. We will pass the
mitochondrial gene symbols into <a href="https://satijalab.org/seurat/reference/percentagefeatureset" class="external-link">PercentageFeatureSet</a>,
which will perform the calculation for us.</p>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">filter_st</span><span class="op">[[</span><span class="st">"percent.mt"</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu">PercentageFeatureSet</span><span class="op">(</span><span class="va">filter_st</span>, pattern <span class="op">=</span> <span class="va">mito_pattern</span><span class="op">)</span></span></code></pre>
</div>
<p>This syntax adds a new column called “percent.mt” to the spot
metadata.</p>
<div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">colnames</span><span class="op">(</span><span class="va">filter_st</span><span class="op">@</span><span class="va">meta.data</span><span class="op">)</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>[1] "orig.ident"         "nCount_Spatial"     "nFeature_Spatial"
[4] "in_tissue"          "array_row"          "array_col"
[7] "pxl_row_in_fullres" "pxl_col_in_fullres" "percent.mt"        </code></pre>
</div>

<p>Let’s look at histograms of the ribosomal and mitochondrial gene
percentages.</p>
<div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">hist</span><span class="op">(</span><span class="fu">FetchData</span><span class="op">(</span><span class="va">filter_st</span>, <span class="st">"percent.mt"</span><span class="op">)</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span>,   main <span class="op">=</span> <span class="st">"% Mitochondrial Genes"</span>,</span>
<span>     xlab <span class="op">=</span> <span class="st">"%"</span><span class="op">)</span></span></code></pre>
</div>
<figure><img src="fig/remove-low-quality-spots-rendered-unnamed-chunk-8-1.png" alt="mito" style="display: block; margin: auto;" class="figure mx-auto d-block"></figure><p>In these plots, we are looking for spots which are outside of a
normal distribution. It is difficult to generalize how to select a
filtering threshold. Some tissue or cell types may have higher
mitochondrial gene expression. Further, heterogeneous tissues may have
subsets of cells with differing levels of mitochondrial gene
expression.</p>
<p>Let’s visually check whether the mitochondrial gene expression is
normally distributed.</p>
<div class="codewrapper sourceCode" id="cb13">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">mito_expr</span> <span class="op">&lt;-</span> <span class="fu">FetchData</span><span class="op">(</span><span class="va">filter_st</span>, <span class="st">"percent.mt"</span><span class="op">)</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span></span>
<span><span class="fu">qqnorm</span><span class="op">(</span><span class="va">mito_expr</span>, las <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="fu">qqline</span><span class="op">(</span><span class="va">mito_expr</span><span class="op">)</span></span></code></pre>
</div>
<figure><img src="fig/remove-low-quality-spots-rendered-unnamed-chunk-9-1.png" alt="mito" style="display: block; margin: auto;" class="figure mx-auto d-block"></figure><p>In this case, there may be a reason to filter out spots with greater
than 35% mitochondrial counts.</p>
</section><section><h2 class="section-heading" id="filter-by-umi-count-and-number-of-detected-genes">Filter by UMI Count and Number of Detected Genes<a class="anchor" aria-label="anchor" href="#filter-by-umi-count-and-number-of-detected-genes"></a>
</h2>
<hr class="half-width">
<p>In the previous lesson, we plotted number of UMIs and genes detected
spatially across the tissue. Let’s plot these values again, but this
time as a histogram.</p>

<div class="codewrapper sourceCode" id="cb14">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">layout</span><span class="op">(</span><span class="fu">matrix</span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu">hist</span><span class="op">(</span><span class="fu">FetchData</span><span class="op">(</span><span class="va">filter_st</span>, <span class="st">"nCount_Spatial"</span><span class="op">)</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span>,</span>
<span>     main <span class="op">=</span> <span class="st">'UMIs per Spot'</span>, xlab <span class="op">=</span> <span class="st">'Counts'</span>, las <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="fu">hist</span><span class="op">(</span><span class="fu">FetchData</span><span class="op">(</span><span class="va">filter_st</span>, <span class="st">"nFeature_Spatial"</span><span class="op">)</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span>, </span>
<span>     main <span class="op">=</span> <span class="st">'Genes per Spot'</span>, xlab <span class="op">=</span> <span class="st">'Genes'</span>, las <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span></code></pre>
</div>
<figure><img src="fig/remove-low-quality-spots-rendered-unnamed-chunk-10-1.png" alt="mito" style="display: block; margin: auto;" class="figure mx-auto d-block"></figure><p>Again, most of the spots fall within a reasonable distribution. The
right tail of the distribution is not very thick. We might filter spots
with over 14,000 UMIs or 3,000 genes. We will use these thresholds to
add a “keep” column to the Seurat object metadata.</p>
<p>First, we will create variables for each threshold. While we could
type the numbers directly into the logical comparison statements,
creating variables makes it clear what each number represents.</p>
<div class="codewrapper sourceCode" id="cb15">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">mito_thr</span>     <span class="op">&lt;-</span> <span class="fl">32</span></span>
<span><span class="va">counts_thr</span>   <span class="op">&lt;-</span> <span class="fl">14000</span></span>
<span><span class="va">features_thr</span> <span class="op">&lt;-</span> <span class="fl">5000</span></span></code></pre>
</div>
<p>Next, we will create a “keep” variable which will be TRUE for spots
that we want to keep.</p>
<div class="codewrapper sourceCode" id="cb16">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">keep</span> <span class="op">&lt;-</span> <span class="fu">FetchData</span><span class="op">(</span><span class="va">filter_st</span>, <span class="st">"percent.mt"</span><span class="op">)</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span>       <span class="op">&lt;</span> <span class="va">mito_thr</span></span>
<span><span class="va">keep</span> <span class="op">&lt;-</span> <span class="fu">FetchData</span><span class="op">(</span><span class="va">filter_st</span>, <span class="st">"nCount_Spatial"</span><span class="op">)</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span>   <span class="op">&lt;</span> <span class="va">counts_thr</span>   <span class="op">&amp;</span> <span class="va">keep</span></span>
<span><span class="va">keep</span> <span class="op">&lt;-</span> <span class="fu">FetchData</span><span class="op">(</span><span class="va">filter_st</span>, <span class="st">"nFeature_Spatial"</span><span class="op">)</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">&lt;</span> <span class="va">features_thr</span> <span class="op">&amp;</span> <span class="va">keep</span></span>
<span></span>
<span><span class="va">filter_st</span><span class="op">$</span><span class="va">keep</span> <span class="op">&lt;-</span> <span class="va">keep</span></span></code></pre>
</div>
<p>Now let’s plot the spots on the tissue and color them based on
whether we will keep them.</p>
<div class="codewrapper sourceCode" id="cb17">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">SpatialDimPlot</span><span class="op">(</span><span class="va">filter_st</span>, group.by <span class="op">=</span> <span class="st">"keep"</span><span class="op">)</span></span></code></pre>
</div>
<figure><img src="fig/remove-low-quality-spots-rendered-unnamed-chunk-13-1.png" style="display: block; margin: auto;" class="figure mx-auto d-block"></figure><p>When you examine the spots that have been flagged, it is important to
look for patterns. If a contiguous section of tissue contains spots that
will be removed, it is worth looking at the histology slide to see if
there are structures that correlate with the removed spots. If it is a
section of necrotic tissue, then, depending on your experimental
question, you may want to remove those spots. But you should always look
for patterns in the removed spots and convince yourself that they are
not biasing your results.</p>
<p>Note that we will only remove a few spots in this filtering step.</p>
<div class="codewrapper sourceCode" id="cb18">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">table</span><span class="op">(</span><span class="fu">FetchData</span><span class="op">(</span><span class="va">filter_st</span>, <span class="st">"keep"</span><span class="op">)</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span><span class="op">)</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>
FALSE  TRUE
    6  3633 </code></pre>
</div>
<p>We can remove the spots directly using the following syntax. In this
case, the “columns” of the Seurat object correspond to the spots.</p>
<div class="codewrapper sourceCode" id="cb20">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">filter_st</span> <span class="op">&lt;-</span> <span class="va">filter_st</span><span class="op">[</span>,<span class="va">keep</span><span class="op">]</span></span></code></pre>
</div>
<div id="challenge-1-change-the-total-counts-spot-filtering-threshold." class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-1-change-the-total-counts-spot-filtering-threshold." class="callout-inner">
<h3 class="callout-title">Challenge 1: Change the total counts spot filtering threshold.</h3>
<div class="callout-content">
<ol style="list-style-type: decimal">
<li>Make a copy of the seurat object.</li>
<li>Change the threshold for the number of UMIs per spot to keep spots
with <strong>more</strong> than 2000 counts. Note that we are filtering
on the lower side of the distribution.</li>
<li>Add new variable called “keep_counts” to the Seurat object.</li>
<li>Plot the spot overlaid on the tissue section, colored by whether you
are keeping them.</li>
</ol>
<p>Is there a pattern to the removed spots that seems to correlate with
the tissue structure?</p>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Solution 1 </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" data-bs-parent="#accordionSolution1" aria-labelledby="headingSolution1">
<div class="accordion-body">
<div class="codewrapper sourceCode" id="cb21">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">obj</span>             <span class="op">&lt;-</span> <span class="va">filter_st</span></span>
<span><span class="va">new_counts_thr</span>  <span class="op">&lt;-</span> <span class="fl">2000</span></span>
<span><span class="va">keep_counts</span>     <span class="op">&lt;-</span> <span class="fu">FetchData</span><span class="op">(</span><span class="va">obj</span>, <span class="st">"nCount_Spatial"</span><span class="op">)</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">&gt;</span> <span class="va">new_counts_thr</span></span>
<span><span class="va">obj</span><span class="op">$</span><span class="va">keep_counts</span> <span class="op">&lt;-</span> <span class="va">keep_counts</span></span>
<span><span class="fu">SpatialDimPlot</span><span class="op">(</span><span class="va">obj</span>, group.by <span class="op">=</span> <span class="st">"keep_counts"</span><span class="op">)</span></span></code></pre>
</div>
<figure><img src="fig/remove-low-quality-spots-rendered-unnamed-chunk-16-1.png" style="display: block; margin: auto;" class="figure mx-auto d-block"></figure><p>Note that the spots that we have flagged seem to correspond to
stripes in the tissue section. These may be regions of the brain which
have lower levels of gene expression, so we may want to revise or remove
this threshold. Overall, this exercise shows that it is important to use
judgement when filtering spots.</p>
</div>
</div>
</div>
</div>
<div id="challenge-2-change-the-mitochondrial-spot-filtering-thresholds." class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-2-change-the-mitochondrial-spot-filtering-thresholds." class="callout-inner">
<h3 class="callout-title">Challenge 2: Change the mitochondrial spot filtering thresholds.</h3>
<div class="callout-content">
<ol style="list-style-type: decimal">
<li>Make a copy of the seurat object.</li>
<li>Change the threshold for the percent mitochondrial expression per
spot to keep spots with <strong>less</strong> than 25% mitochondrial
expression. This might happen if you decide that too much mitochondrial
expression indicates some technical error.</li>
<li>Add new variable called “keep_counts” to the Seurat object.</li>
<li>Plot the spot overlaid on the tissue section, colored by whether you
are keeping them.</li>
</ol>
<p>Is there a pattern to the removed spots that seems to correlate with
the tissue structure?</p>
</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2"> Solution 2 </h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" data-bs-parent="#accordionSolution2" aria-labelledby="headingSolution2">
<div class="accordion-body">
<div class="codewrapper sourceCode" id="cb22">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">obj</span>          <span class="op">&lt;-</span> <span class="va">filter_st</span></span>
<span><span class="va">new_mito_thr</span> <span class="op">&lt;-</span> <span class="fl">20</span></span>
<span><span class="va">keep_counts</span>  <span class="op">&lt;-</span> <span class="fu">FetchData</span><span class="op">(</span><span class="va">obj</span>, <span class="st">"percent.mt"</span><span class="op">)</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">&lt;</span> <span class="va">new_mito_thr</span></span>
<span><span class="va">obj</span><span class="op">$</span><span class="va">keep_counts</span> <span class="op">&lt;-</span> <span class="va">keep_counts</span></span>
<span><span class="fu">SpatialDimPlot</span><span class="op">(</span><span class="va">obj</span>, group.by <span class="op">=</span> <span class="st">"keep_counts"</span><span class="op">)</span></span></code></pre>
</div>
<figure><img src="fig/remove-low-quality-spots-rendered-unnamed-chunk-17-1.png" style="display: block; margin: auto;" class="figure mx-auto d-block"></figure><p>Note that the spots that we have flagged are largely outside of the
lower left. Later in the lesson, we will find that this is the “white
matter”, and this region has different expression from the rest of the
tissue section. In fact, mitochondrial expression in general seems to be
higher in the upper right area.</p>
<div class="codewrapper sourceCode" id="cb23">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">SpatialFeaturePlot</span><span class="op">(</span><span class="va">obj</span>, features <span class="op">=</span> <span class="st">"percent.mt"</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">labs</span><span class="op">(</span>title <span class="op">=</span> <span class="st">"Percentage MitochondrialExpression"</span><span class="op">)</span></span></code></pre>
</div>
<figure><img src="fig/remove-low-quality-spots-rendered-unnamed-chunk-18-1.png" style="display: block; margin: auto;" class="figure mx-auto d-block"></figure><div class="codewrapper sourceCode" id="cb24">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">rm</span><span class="op">(</span><span class="va">obj</span><span class="op">)</span></span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>Spot filtering should be light.</li>
<li>Inspect the spots that you are filtering to confirm that you are not
discarding important tissue structures.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-apply-normalization-methods"><p>Content from <a href="apply-normalization-methods.html">Normalization in Spatial Transcriptomics</a></p>
<hr>
<p>Last updated on 2025-03-04 |

        <a href="https://github.com/smcclatchy/spatial-transcriptomics/edit/main/episodes/apply-normalization-methods.Rmd" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What technical and biological factors impact spatial transcriptomics
data?</li>
<li>How do these factors motivate the need for normalization?</li>
<li>What are popular normalization methods?</li>
<li>How do we assess the impact of normalization?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Understand and learn to apply popular normalization techniques, such
as CPM normalization, log normalization, and SCTransform.</li>
<li>Diagnose the impact of normalization.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="understanding-normalization-in-spatial-transcriptomics">Understanding Normalization in Spatial Transcriptomics<a class="anchor" aria-label="anchor" href="#understanding-normalization-in-spatial-transcriptomics"></a>
</h2>
<hr class="half-width">
<p>As with scRNA-seq data, normalization is necessary to overcome two
technical artifacts in spatial transcriptomics:</p>
<ol style="list-style-type: decimal">
<li>the difference in total counts across spots, and</li>
<li>the dependence of a gene’s expression variance on its expression
level.</li>
</ol>
<p>The number of total counts in a spot is termed its <em>library
size</em>. Since library sizes differ across spots, it will be difficult
to compare gene expression values between them in a meaningful way
because the denominator (total spot counts) is different in each spot.
On the other hand, different spots may contain different types of cells,
which may express differing numbers of transcripts. So there is a
balance between normalizing all spots to have the same total counts and
leaving some variation in total counts which may be due to the biology
of the tissue. In general, we want to be cautious that removing the
above technical artifacts may also obscure true biological
differences.</p>
<p>Regarding the second artifact, we will see below that the variance in
a gene’s expression scales with its expression. If we do not correct for
this effect, differentially expressed genes will be skewed towards the
high end of the expression spectrum. Hence, we seek to <em>stabilize the
variance</em> – <em>i.e.</em>, transform the data such that expression
variance is independent of mean expression.</p>
<p>In this lesson we will:</p>
<ul>
<li>Observe that total spots per spot are variable</li>
<li>Explore biological factors that contribute to that variability</li>
<li>See that gene expression variance is correlated with mean
expression</li>
<li>Apply three methods aimed at mitigating one or both of these
technical observations: counts per million (CPM) normalization, log
normalization, and Seurat’s SCTransform</li>
</ul>
<div class="section level3">
<h3 id="total-counts-per-spot-are-variable">Total Counts per Spot are Variable<a class="anchor" aria-label="anchor" href="#total-counts-per-spot-are-variable"></a>
</h3>
<p>Let’s first assess the variability in the total counts per spot.</p>
<p>The spots are arranged in columns in the data matrix. We will look at
the distribution of total counts per spot by summing the counts in each
column and making a histogram.</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Extract the raw counts (gene by spot matrix) from the Seurat object</span></span>
<span><span class="va">counts</span> <span class="op">&lt;-</span> <span class="fu">LayerData</span><span class="op">(</span><span class="va">filter_st</span>, layer <span class="op">=</span> <span class="st">'counts'</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Plot a histogram of the total counts (library size or sum across genes).</span></span>
<span><span class="co"># Note that this column sum is also encoded in the nCount_Spatial metadata</span></span>
<span><span class="co"># variable. We could have simply made a histogram of that variable.</span></span>
<span><span class="fu">hist</span><span class="op">(</span><span class="fu">colSums2</span><span class="op">(</span><span class="va">counts</span><span class="op">)</span>, breaks <span class="op">=</span> <span class="fl">100</span>, </span>
<span>     main <span class="op">=</span> <span class="st">"Histogram of Counts per Spot"</span><span class="op">)</span></span></code></pre>
</div>
<figure><img src="fig/apply-normalization-methods-rendered-unnamed-chunk-2-1.png" style="display: block; margin: auto;" class="figure mx-auto d-block"></figure><p>As you can see, the total counts per spot ranges cross four orders of
magnitude. Some of this may be due to the biology of the tissue,
<em>i.e.</em> some cells may express more transcripts. But some of this
may be due to technical issues. Let’s explore each of these two
considerations further.</p>
</div>
<div class="section level3">
<h3 id="sources-of-biological-variation-in-total-counts">Sources of Biological Variation in Total Counts<a class="anchor" aria-label="anchor" href="#sources-of-biological-variation-in-total-counts"></a>
</h3>
<p>Hematoxylin and Eosin (H&amp;E) staining is routinely performed on
tissue sections in the clinic for diagnosis. Hematoxylin stains nuclei
purple or blue and eosin stains cytoplasm and extracellular matrix pink.
Collectively, they elucidate tissue and cellular morphology, which can
guide interpretation of transcriptomic data. For example, observing high
RNA counts in a necrotic region, which should instead have fewer cells,
might suggest technical artifacts and, thus, indicate a need for
normalization.</p>
<p>Maynard and colleagues used the information encoded in the H&amp;E,
in particular cellular organization, morphology, and density, in
conjunction with expression data to annotate the six layers and the
white matter of the neocortex. Additionally, they applied standard image
processing techniques to the H&amp;E image to segment and count nuclei
under each spot. They provide this as metadata. Let’s load that layer
annotation and cell count metadata and add it to our Seurat object.</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Load the metadata provided by Maynard et al.</span></span>
<span><span class="va">spot_metadata</span> <span class="op">&lt;-</span> <span class="fu">read.table</span><span class="op">(</span><span class="st">"./data/spot-meta.tsv"</span>, sep<span class="op">=</span><span class="st">"\t"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Subset the metadata (across all samples) to our sample</span></span>
<span><span class="va">spot_metadata</span> <span class="op">&lt;-</span> <span class="fu">subset</span><span class="op">(</span><span class="va">spot_metadata</span>, <span class="va">sample_name</span> <span class="op">==</span> <span class="fl">151673</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Format the metadata by setting rowname to the barcode (id) of each spot,</span></span>
<span><span class="co"># by ensuring that each spot in our data is represented in the metadata,</span></span>
<span><span class="co"># and by ordering the spots within the metadata consistently with the data.</span></span>
<span><span class="fu">rownames</span><span class="op">(</span><span class="va">spot_metadata</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="va">spot_metadata</span><span class="op">$</span><span class="va">barcode</span></span>
<span><span class="fu">stopifnot</span><span class="op">(</span><span class="fu">all</span><span class="op">(</span><span class="fu">Cells</span><span class="op">(</span><span class="va">filter_st</span><span class="op">)</span> <span class="op">%in%</span> <span class="fu">rownames</span><span class="op">(</span><span class="va">spot_metadata</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">spot_metadata</span> <span class="op">&lt;-</span> <span class="va">spot_metadata</span><span class="op">[</span><span class="fu">Cells</span><span class="op">(</span><span class="va">filter_st</span><span class="op">)</span>,<span class="op">]</span></span>
<span></span>
<span><span class="co"># Add the layer annotation (layer_guess) and cell count as </span></span>
<span><span class="co"># metadata to the Seurat object using AddMetaData.</span></span>
<span><span class="va">filter_st</span> <span class="op">&lt;-</span> <span class="fu">AddMetaData</span><span class="op">(</span>object <span class="op">=</span> <span class="va">filter_st</span>,</span>
<span>                         metadata <span class="op">=</span> <span class="va">spot_metadata</span><span class="op">[</span>, <span class="fu">c</span><span class="op">(</span><span class="st">"layer_guess"</span>, <span class="st">"cell_count"</span><span class="op">)</span>, drop<span class="op">=</span><span class="cn">FALSE</span><span class="op">]</span><span class="op">)</span></span></code></pre>
</div>
<p>Now, we can plot the layer annotations to understand the structure of
the tissue. We will use a simple wrapper,
<code>SpatialDimPlotColorSafe</code>, around the Seurat function
<code>SpatialDimPlot</code>. This is defined in
<code>code/spatial_utils.R</code> and uses a color-blind safe
palette.</p>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Plot the layer annotations on the tissue, omitting any spots</span></span>
<span><span class="co"># that do not have annotations (*i.e.*, having NA values)</span></span>
<span><span class="fu">SpatialDimPlotColorSafe</span><span class="op">(</span><span class="va">filter_st</span><span class="op">[</span>, <span class="op">!</span><span class="fu">is.na</span><span class="op">(</span><span class="va">filter_st</span><span class="op">[[</span><span class="op">]</span><span class="op">]</span><span class="op">$</span><span class="va">layer_guess</span><span class="op">)</span><span class="op">]</span>,</span>
<span>                        <span class="st">"layer_guess"</span><span class="op">)</span> <span class="op">+</span> <span class="fu">labs</span><span class="op">(</span>fill<span class="op">=</span><span class="st">"Layer"</span><span class="op">)</span></span></code></pre>
</div>
<figure><img src="fig/apply-normalization-methods-rendered-unnamed-chunk-4-1.png" style="display: block; margin: auto;" class="figure mx-auto d-block"></figure><p>We noted that the authors used cellular density to aid in discerning
layers. Let’s see how those H&amp;E-derived cell counts vary across
layers.</p>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Make a boxplot of spot-level cell counts, faceted by layer annotation.</span></span>
<span><span class="co"># As above, remove any spots without annotations (*i.e.*, having NA values).</span></span>
<span><span class="va">g</span> <span class="op">&lt;-</span> <span class="fu">ggplot</span><span class="op">(</span><span class="fu">na.omit</span><span class="op">(</span><span class="va">filter_st</span><span class="op">[[</span><span class="op">]</span><span class="op">]</span><span class="op">[</span>, <span class="fu">c</span><span class="op">(</span><span class="st">"layer_guess"</span>, <span class="st">"cell_count"</span><span class="op">)</span><span class="op">]</span><span class="op">)</span>, </span>
<span>            <span class="fu">aes</span><span class="op">(</span>x <span class="op">=</span> <span class="va">layer_guess</span>, y <span class="op">=</span> <span class="va">cell_count</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">g</span> <span class="op">&lt;-</span> <span class="va">g</span> <span class="op">+</span> <span class="fu">geom_boxplot</span><span class="op">(</span><span class="op">)</span> <span class="op">+</span> <span class="fu">xlab</span><span class="op">(</span><span class="st">"Layer"</span><span class="op">)</span> <span class="op">+</span> <span class="fu">ylab</span><span class="op">(</span><span class="st">"Cell Count"</span><span class="op">)</span></span>
<span><span class="va">g</span></span></code></pre>
</div>
<figure><img src="fig/apply-normalization-methods-rendered-unnamed-chunk-5-1.png" style="display: block; margin: auto;" class="figure mx-auto d-block"></figure><p>We see that the white matter (WM) has increased cells per spot,
whereas Layer 1 has fewer cells per spot.</p>
<p>We can also plot these cell counts spatially.</p>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">SpatialFeaturePlot</span><span class="op">(</span><span class="va">filter_st</span>, <span class="st">"cell_count"</span><span class="op">)</span></span></code></pre>
</div>
<figure><img src="fig/apply-normalization-methods-rendered-unnamed-chunk-6-1.png" style="display: block; margin: auto;" class="figure mx-auto d-block"></figure><p>The cell counts partially reflect the banding of the layers.</p>
<p>As a potential surrogate for cell count, let’s plot the total counts
(number of UMIs or library size) per spot as a function of layer.</p>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Make a boxplot of spot-level total read counts (library size), faceted by layer annotation.</span></span>
<span><span class="co"># Remove any spots without annotations (*i.e.*, having NA values).</span></span>
<span><span class="va">g</span> <span class="op">&lt;-</span> <span class="fu">ggplot</span><span class="op">(</span><span class="fu">na.omit</span><span class="op">(</span><span class="va">filter_st</span><span class="op">[[</span><span class="op">]</span><span class="op">]</span><span class="op">[</span>, <span class="fu">c</span><span class="op">(</span><span class="st">"layer_guess"</span>, <span class="st">"nCount_Spatial"</span><span class="op">)</span><span class="op">]</span><span class="op">)</span>, </span>
<span>            <span class="fu">aes</span><span class="op">(</span>x <span class="op">=</span> <span class="va">layer_guess</span>, y <span class="op">=</span> <span class="va">nCount_Spatial</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">g</span> <span class="op">&lt;-</span> <span class="va">g</span> <span class="op">+</span> <span class="fu">geom_boxplot</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">g</span></span></code></pre>
</div>
<figure><img src="fig/apply-normalization-methods-rendered-unnamed-chunk-7-1.png" style="display: block; margin: auto;" class="figure mx-auto d-block"></figure><p>Layer 1 has fewer total read counts, consistent with its lower cell
count. An increase in total read counts consistent with that in cell
count is not observed for the white matter, however. Regardless, there
are clear differences in total read counts across brain layers.</p>
<p>In summary, we have observed that both total read counts (library
size) and feature counts (number of detected genes) can encode
biological information. As such, we strongly recommend visualizing raw
gene and features counts prior to normalization, which would remove
differences in library size across spots.</p>
</div>
<div class="section level3">
<h3 id="normalization-techniques-to-mitigate-sources-of-technical-variation-in-total-counts">Normalization Techniques to Mitigate Sources of Technical Variation
in Total Counts<a class="anchor" aria-label="anchor" href="#normalization-techniques-to-mitigate-sources-of-technical-variation-in-total-counts"></a>
</h3>
<div class="section level4">
<h4 id="counts-per-million-library-size-normalization">“Counts Per Million” Library Size Normalization<a class="anchor" aria-label="anchor" href="#counts-per-million-library-size-normalization"></a>
</h4>
<p>The first technical issue we noted above was a difference in total
counts or library size across spots. A straightfoward means of
addressing this is simply to divide all gene counts within the spot by
the total counts in that spot. Conventionally, we then multiply by a
million, which yields “counts per million” (CPM). Adopting this
particular factor consistently establishes a standard scale across
studies.</p>
<p>You should be aware, however, that the CPM approach is susceptible to
“compositional bias” – if a small number of genes make a large
contribution to the total count, any significant fluctuation in their
expression across samples will impact the quantification of <em>all
other</em> genes. To overcome this, more robust measures of library size
that are more resilient to compositional bias are sometimes used,
including the 75th percentile of counts within a sample (or here, spot).
For simplicity, here we will use CPM.</p>
<p>In Seurat, we can apply this transformation via the
<code>NormalizeData</code> function, parameterized by the relative
counts (or “RC”) normalization method. We scale the results to a million
cells through the <code>scale.factor</code> parameter.</p>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Apply CPM normalization using NormalizeData, by specifying the relative</span></span>
<span><span class="co"># counts (RC) normalization.method and a scale factor of one million.</span></span>
<span><span class="va">cpm_st</span> <span class="op">&lt;-</span> <span class="fu">NormalizeData</span><span class="op">(</span><span class="va">filter_st</span>, </span>
<span>                        assay                <span class="op">=</span> <span class="st">"Spatial"</span>, </span>
<span>                        normalization.method <span class="op">=</span> <span class="st">"RC"</span>, </span>
<span>                        scale.factor         <span class="op">=</span> <span class="fl">1e6</span><span class="op">)</span></span></code></pre>
</div>
<p><code>NormalizeData</code> adds a <code>data</code> object to the
Seurat object.</p>
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Access the layers of the Seurat object</span></span>
<span><span class="fu">Layers</span><span class="op">(</span><span class="va">cpm_st</span><span class="op">)</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>[1] "counts" "data"  </code></pre>
</div>
<p>We can confirm that we have indeed normalized away differences in
total counts – all spots now have one million reads:</p>
<div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Examine the total counts in each spot, as the sum of the columns.</span></span>
<span><span class="co"># As above, we could have also used nCount_Spatial in the metadata.</span></span>
<span><span class="fu">head</span><span class="op">(</span><span class="fu">colSums</span><span class="op">(</span><span class="fu">LayerData</span><span class="op">(</span><span class="va">cpm_st</span>, <span class="st">"data"</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>AAACAAGTATCTCCCA-1 AAACAATCTACTAGCA-1 AAACACCAATAACTGC-1 AAACAGAGCGACTCCT-1
             1e+06              1e+06              1e+06              1e+06
AAACAGCTTTCAGAAG-1 AAACAGGGTCTATATT-1
             1e+06              1e+06 </code></pre>
</div>
<p>Our second concern was that variance might differ across genes in an
expression dependent manner. To diagnose this, we will make a so-called
mean-variance plot, with each gene’s mean expression across spots on the
x axis and its variance across spots on the y axis. This shows any
potential trends between each gene’s mean expression and the variance of
that expression.</p>
<div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Extract the CPM data computed above</span></span>
<span><span class="va">cpms</span>      <span class="op">&lt;-</span> <span class="fu">LayerData</span><span class="op">(</span><span class="va">cpm_st</span>, <span class="st">"data"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Calculate the mean and variance of the CPMs</span></span>
<span><span class="va">means</span>     <span class="op">&lt;-</span> <span class="fu">apply</span><span class="op">(</span><span class="va">cpms</span>, <span class="fl">1</span>, <span class="va">mean</span><span class="op">)</span></span>
<span><span class="va">vars</span>      <span class="op">&lt;-</span> <span class="fu">apply</span><span class="op">(</span><span class="va">cpms</span>, <span class="fl">1</span>, <span class="va">var</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Assemble the mean and variance into a data.frame</span></span>
<span><span class="va">gene.info</span> <span class="op">&lt;-</span> <span class="fu">data.frame</span><span class="op">(</span>mean <span class="op">=</span> <span class="va">means</span>, variance <span class="op">=</span> <span class="va">vars</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Plot the mean expression on the x axis and the variance in expression on </span></span>
<span><span class="co"># the y axis</span></span>
<span><span class="va">g</span> <span class="op">&lt;-</span> <span class="fu">ggplot</span><span class="op">(</span><span class="op">)</span> <span class="op">+</span> <span class="fu">geom_point</span><span class="op">(</span>data <span class="op">=</span> <span class="va">gene.info</span>, <span class="fu">aes</span><span class="op">(</span>x <span class="op">=</span> <span class="va">mean</span>, y <span class="op">=</span> <span class="va">variance</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co"># Log transform both axes</span></span>
<span><span class="va">g</span> <span class="op">&lt;-</span> <span class="va">g</span> <span class="op">+</span> <span class="fu">scale_x_continuous</span><span class="op">(</span>trans<span class="op">=</span><span class="st">'log2'</span><span class="op">)</span> <span class="op">+</span> <span class="fu">scale_y_continuous</span><span class="op">(</span>trans<span class="op">=</span><span class="st">'log2'</span><span class="op">)</span></span>
<span><span class="va">g</span> <span class="op">&lt;-</span> <span class="va">g</span> <span class="op">+</span> <span class="fu">xlab</span><span class="op">(</span><span class="st">"Log Mean Expression"</span><span class="op">)</span> <span class="op">+</span> <span class="fu">ylab</span><span class="op">(</span><span class="st">"Log Mean Variance"</span><span class="op">)</span></span>
<span><span class="va">g</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">WARNING<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="warning" tabindex="0"><code>Warning in scale_x_continuous(trans = "log2"): log-2 transformation introduced
infinite values.</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">WARNING<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="warning" tabindex="0"><code>Warning in scale_y_continuous(trans = "log2"): log-2 transformation introduced
infinite values.</code></pre>
</div>
<figure><img src="fig/apply-normalization-methods-rendered-unnamed-chunk-11-1.png" style="display: block; margin: auto;" class="figure mx-auto d-block"></figure><p>There is a clear relationship between the mean and variance of gene
expression. Our goal was instead that the variance be independent of the
mean. One way of achieving this is to <em>detrend</em> the data by
fitting a smooth curve to the mean-variance plot. This fit will capture
the general behavior of most genes. And, since we expect most genes to
exhibit technical variability only and not biological variability
additionally, this trend will reflect technical variance. Let’s start by
characterizing the trend in the data by fitting them with a smooth line.
We will use LOESS (locally estimated scatterplot smoothing) regression,
an approach originally developed to fit a smooth line through data
points in a scatterplot.</p>
<div class="codewrapper sourceCode" id="cb15">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># This is the default LOESS span used by Seurat in FindVariableFeatures</span></span>
<span><span class="va">loess.span</span> <span class="op">&lt;-</span> <span class="fl">0.3</span></span>
<span></span>
<span><span class="co"># Exclude genes with constant variance from our fit.</span></span>
<span><span class="va">not.const</span>  <span class="op">&lt;-</span> <span class="va">gene.info</span><span class="op">$</span><span class="va">variance</span> <span class="op">&gt;</span> <span class="fl">0</span></span>
<span></span>
<span><span class="co"># Fit a LOESS trend line relating the (log10) gene expression variance</span></span>
<span><span class="co"># to the (log10) gene expression mean, but only for the non-constant</span></span>
<span><span class="co"># variance genes.</span></span>
<span><span class="va">fit</span> <span class="op">&lt;-</span> <span class="fu">loess</span><span class="op">(</span>formula <span class="op">=</span> <span class="fu">log10</span><span class="op">(</span>x <span class="op">=</span> <span class="va">variance</span><span class="op">)</span> <span class="op">~</span> <span class="fu">log10</span><span class="op">(</span>x <span class="op">=</span> <span class="va">mean</span><span class="op">)</span>,</span>
<span>             data <span class="op">=</span> <span class="va">gene.info</span><span class="op">[</span><span class="va">not.const</span>, <span class="op">]</span>, span <span class="op">=</span> <span class="va">loess.span</span><span class="op">)</span></span></code></pre>
</div>
<p>Let’s now plot the fitted/expected variances as a function of the
observed means.</p>
<div class="codewrapper sourceCode" id="cb16">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># The expected variance computed from the model are in fit$fitted.</span></span>
<span><span class="co"># Exponentiate because the original model was fit to log10-transformed means and variances.</span></span>
<span><span class="va">gene.info</span><span class="op">$</span><span class="va">variance.expected</span>               <span class="op">&lt;-</span> <span class="cn">NA</span></span>
<span><span class="va">gene.info</span><span class="op">[</span><span class="va">not.const</span>, <span class="st">"variance.expected"</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">10</span><span class="op">^</span><span class="va">fit</span><span class="op">$</span><span class="va">fitted</span></span>
<span></span>
<span><span class="co"># Plot the expected variance as a function of the observed means for only</span></span>
<span><span class="co"># the non-constant variance genes.</span></span>
<span><span class="va">g</span> <span class="op">&lt;-</span> <span class="va">g</span> <span class="op">+</span> <span class="fu">geom_line</span><span class="op">(</span>data <span class="op">=</span> <span class="fu">na.omit</span><span class="op">(</span><span class="va">gene.info</span><span class="op">[</span><span class="va">not.const</span>,<span class="op">]</span><span class="op">)</span>,</span>
<span>                   <span class="fu">aes</span><span class="op">(</span>x <span class="op">=</span> <span class="va">mean</span>, y <span class="op">=</span> <span class="va">variance.expected</span><span class="op">)</span>, linewidth <span class="op">=</span> <span class="fl">3</span>, color <span class="op">=</span> <span class="st">"blue"</span><span class="op">)</span>            </span>
<span><span class="va">g</span>             </span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">WARNING<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="warning" tabindex="0"><code>Warning in scale_x_continuous(trans = "log2"): log-2 transformation introduced
infinite values.</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">WARNING<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="warning" tabindex="0"><code>Warning in scale_y_continuous(trans = "log2"): log-2 transformation introduced
infinite values.</code></pre>
</div>
<figure><img src="fig/apply-normalization-methods-rendered-unnamed-chunk-13-1.png" style="display: block; margin: auto;" class="figure mx-auto d-block"></figure><p>We see that the trend line nicely fits the data – <em>i.e.</em>, it
characterizes the observed variance as a function of the mean for the
vast majority of genes.</p>
<p>We now follow the logic applied in Seurat, as described by <a href="https://genomebiology.biomedcentral.com/articles/10.1186/s13059-019-1874-1" class="external-link">Hafemeister
and Satija</a>. We define the “standardized variance” as the variance in
the expression values after those expression values have been
standardized by the trend line (<em>i.e.</em>, they have been mean
centered and divided by the predicted variance).</p>
<p>As we did above, we can use a mean-variance plot to diagnose whether
our transformation, here the standardized variance, has indeed
stabilized the variance across different mean expression ranges. In
particular, since we expect <em>most</em> genes to have only technical
(and not also biological) variance, the trend line should be dominated
by those genes and will capture the technical variance. As such, the
standardized variance should be near one for most genes – those with
only technical variance. Genes with additional biological variance will
deviate from the trend line and also from the near-one standardized
variance. Is this what we observe?</p>
<div class="codewrapper sourceCode" id="cb19">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">gene.info</span><span class="op">$</span><span class="va">variance.standardized</span> <span class="op">&lt;-</span> <span class="cn">NA</span></span>
<span></span>
<span><span class="co"># Compute standardized CPM = ( CPM - mean_CPM ) / sqrt(expected_variance)</span></span>
<span><span class="va">standardized.cpms</span> <span class="op">&lt;-</span> </span>
<span>   <span class="op">(</span><span class="va">cpms</span><span class="op">[</span><span class="va">not.const</span>,<span class="op">]</span> <span class="op">-</span> <span class="va">means</span><span class="op">[</span><span class="va">not.const</span><span class="op">]</span><span class="op">)</span> <span class="op">/</span> <span class="fu">sqrt</span><span class="op">(</span><span class="va">gene.info</span><span class="op">[</span><span class="va">not.const</span>, <span class="st">"variance.expected"</span><span class="op">]</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Calculate the "standardized variance" -- *i.e.*, the variance of the standardized CPMs</span></span>
<span><span class="va">gene.info</span><span class="op">[</span><span class="va">not.const</span>, <span class="st">"variance.standardized"</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu">apply</span><span class="op">(</span><span class="va">standardized.cpms</span>, <span class="fl">1</span>, <span class="va">var</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Plot the standardized variance for the non-constant variance genes</span></span>
<span><span class="va">g</span> <span class="op">&lt;-</span> <span class="fu">ggplot</span><span class="op">(</span><span class="op">)</span> <span class="op">+</span> <span class="fu">geom_point</span><span class="op">(</span>data <span class="op">=</span> <span class="va">gene.info</span><span class="op">[</span><span class="va">not.const</span>,<span class="op">]</span>, <span class="fu">aes</span><span class="op">(</span>x <span class="op">=</span> <span class="va">mean</span>, y <span class="op">=</span> <span class="va">variance.standardized</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">g</span> <span class="op">&lt;-</span> <span class="va">g</span> <span class="op">+</span> <span class="fu">geom_hline</span><span class="op">(</span>yintercept <span class="op">=</span> <span class="fl">1</span>, colour <span class="op">=</span> <span class="st">"yellow"</span><span class="op">)</span></span>
<span><span class="co"># Log10-transform the x axis</span></span>
<span><span class="va">g</span> <span class="op">&lt;-</span> <span class="va">g</span> <span class="op">+</span> <span class="fu">scale_x_log10</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">g</span> <span class="op">&lt;-</span> <span class="va">g</span> <span class="op">+</span> <span class="fu">xlab</span><span class="op">(</span><span class="st">"Log Mean CPM"</span><span class="op">)</span> <span class="op">+</span> <span class="fu">ylab</span><span class="op">(</span><span class="st">"Variance of\nTrend-Standardized CPMs"</span><span class="op">)</span></span>
<span><span class="va">g</span></span></code></pre>
</div>
<figure><img src="fig/apply-normalization-methods-rendered-unnamed-chunk-14-1.png" style="display: block; margin: auto;" class="figure mx-auto d-block"></figure><p>Indeed, many genes do have a variance near one.</p>
<p>Seurat provides more efficient means for calculating expression
means, variances, variances predicted from the trend, and the variance
of means standardized by the predicted variances, namely <a href="https://satijalab.org/seurat/reference/findvariablefeatures" class="external-link"><code>FindVariableFeatures</code></a>.
The computed results can then be formatted into a data frame using <a href="https://satijalab.org/seurat/reference/hvfinfo.sctassay" class="external-link"><code>HVFInfo</code></a>.
Be advised that these functions can calculate expected variances using
models that are dependent on input parameters and, sometimes implicitly,
based on different data formats (e.g., raw counts or normalized
expression values). In this case, the values we computed above
manually:</p>
<div class="codewrapper sourceCode" id="cb20">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">head</span><span class="op">(</span><span class="va">gene.info</span><span class="op">)</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>                  mean    variance variance.expected variance.standardized
MIR1302-2HG 0.04896898    8.711791          7.998485             1.0891801
AL627309.1  0.71174425  141.672131        212.427026             0.6669214
AL669831.5  5.45042760 1452.565233       1698.941124             0.8549827
FAM87B      0.09675030   34.007136         21.967802             1.5480446
LINC00115   0.81579878  188.767639        245.068894             0.7702636
FAM41C      1.36714334  338.634811        418.031204             0.8100707</code></pre>
</div>
<p>are the same, with few exceptions, to those computed by the
equivalent Seurat functions:</p>
<div class="codewrapper sourceCode" id="cb22">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Compute expression means and variances using FindVariableFeatures.</span></span>
<span><span class="co"># By passing the total number of genes as nfeatures, we force FindVariableFeatures to</span></span>
<span><span class="co"># compute these metrics for all genes, not just the most variable ones.</span></span>
<span><span class="co"># The metrics will be computed on the specified layer ("data") of the active assay -- here, the</span></span>
<span><span class="co"># CPMs we computed above.</span></span>
<span><span class="co"># Finally, we will use the "vst" (variance-stabilizing transformation) method for selecting highly</span></span>
<span><span class="co"># variable genes.</span></span>
<span><span class="va">cpm_st</span> <span class="op">&lt;-</span> <span class="fu">FindVariableFeatures</span><span class="op">(</span><span class="va">cpm_st</span>, nfeatures <span class="op">=</span> <span class="fu">dim</span><span class="op">(</span><span class="va">cpm_st</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span>, layer<span class="op">=</span><span class="st">"data"</span>, selection.method <span class="op">=</span> <span class="st">"vst"</span><span class="op">)</span></span>
<span><span class="va">cinfo</span> <span class="op">&lt;-</span> <span class="fu">HVFInfo</span><span class="op">(</span><span class="va">cpm_st</span><span class="op">)</span></span>
<span><span class="fu">head</span><span class="op">(</span><span class="va">cinfo</span><span class="op">)</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>                  mean    variance variance.expected variance.standardized
MIR1302-2HG 0.04896898    8.711791          7.998485             1.0005751
AL627309.1  0.71174425  141.672131        212.427026             0.6669214
AL669831.5  5.45042760 1452.565233       1698.941124             0.8549827
FAM87B      0.09675030   34.007136         21.967802             1.0007014
LINC00115   0.81579878  188.767639        245.068894             0.7702636
FAM41C      1.36714334  338.634811        418.031204             0.8100707</code></pre>
</div>
<p>The above code applies the “vst” or variance-stabilizing
transformation to detect highly variable genes. This is essentially the
loess fitting and standardized variance computation that we performed
above. More details are available in the FindVariableFeatures
documentation. We can verify that this FindVariableFeatures functions
gives us similar results to those we manually computed above by using <a href="https://satijalab.org/seurat/reference/variablefeatureplot" class="external-link"><code>VariableFeaturePlot</code></a>
to plot the relationship between the mean expression and the variance of
the trend-standardized expression.</p>
<div class="codewrapper sourceCode" id="cb24">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">VariableFeaturePlot</span><span class="op">(</span><span class="va">cpm_st</span><span class="op">)</span> <span class="op">+</span> <span class="fu">NoLegend</span><span class="op">(</span><span class="op">)</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">WARNING<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="warning" tabindex="0"><code>Warning in scale_x_log10(): log-10 transformation introduced infinite values.</code></pre>
</div>
<figure><img src="fig/apply-normalization-methods-rendered-unnamed-chunk-17-1.png" style="display: block; margin: auto;" class="figure mx-auto d-block"></figure><p>Notice that this plot is similar to that we created manually.</p>
<p>In both our manual plot and the one created by
FindVariableFeatures/VariableFeaturePlot the “standardized” variance of
most genes is near one. Achieving such a flat trend line is our
objective and a good indication that we have stabilized the variance
across a wide range of expression values. Yet, in both, there remains an
evident, if subtle, trend in the plot between mean and variance. Let’s
next look at two common transformations aimed at further stabilizing the
variance across genes – <em>i.e.</em>, for further mitigating the
relationship between gene expression and variance – log-normalization
and SCTransform.</p>
</div>
<div class="section level4">
<h4 id="lognormalize">LogNormalize<a class="anchor" aria-label="anchor" href="#lognormalize"></a>
</h4>
<p>One common approach that attempts to meet our two objectives above –
normalizing for different total spot counts and for expression-dependent
variance – is log-transformation of normalized counts. The resulting
values are often ambiguously referred to as log-normalized counts, which
elides stating that the raw counts are first normalized or scaled and
then log transformed. Scaling accounts for the differences in
spot-specific RNA counts, as with CPMs above. The log transformation
reduces skewness caused by highly expressed genes and stabilizes the
variance, at least for certain mean-variance relationships. In practice,
the log transformation is applied to <i>1+x</i>, where <i>x</i> is the
scaled expression value – the so-called <em>log1p</em> transformation.
This avoids taking the log of zero.</p>
<p>In Seurat, we can apply this transformation by specifying
<code>LogNormalize</code> as the <code>normalization.method</code>
parameter to the same <code>NormalizeData</code> function we applied
above to compute CPMs.</p>
<div class="codewrapper sourceCode" id="cb26">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Apply log normalization using NormalizeData, by specifying the</span></span>
<span><span class="co"># LogNormalize normalization.method and a scale factor of one million.</span></span>
<span><span class="va">lognorm_st</span> <span class="op">&lt;-</span> <span class="fu">NormalizeData</span><span class="op">(</span><span class="va">filter_st</span>, </span>
<span>                           assay                <span class="op">=</span> <span class="st">"Spatial"</span>, </span>
<span>                           normalization.method <span class="op">=</span> <span class="st">"LogNormalize"</span>, </span>
<span>                           scale.factor         <span class="op">=</span> <span class="fl">1e6</span><span class="op">)</span></span></code></pre>
</div>
<p>This function first normalizes the raw counts by
<code>scale.factor</code> before applying the log1p transformation. As
above, we set the <code>scale.factor</code> parameter such that we first
compute CPMs and then apply log1p to these CPMs.</p>
<p>As above, log normalization adds a <code>data</code> object to the
Seurat object.</p>
<div class="codewrapper sourceCode" id="cb27">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Access the layers of the Seurat object</span></span>
<span><span class="fu">Layers</span><span class="op">(</span><span class="va">lognorm_st</span><span class="op">)</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>[1] "counts" "data"  </code></pre>
</div>
<p>Let’s again plot the relationship between the expression mean and its
standardized variance. Additionally, we will highlight those genes that
have standardized variance significantly larger than one. These are
likely to exhibit biological variation.</p>
<div class="codewrapper sourceCode" id="cb29">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Compute highly variable genes and their expression means and variances using FindVariableFeatures.</span></span>
<span><span class="co"># Apply this to the log-transformed data, by specifying the "data" layer of the active assay.</span></span>
<span><span class="co"># As above, use the vst method for computing variable genes.</span></span>
<span><span class="va">lognorm_st</span> <span class="op">&lt;-</span> <span class="fu">FindVariableFeatures</span><span class="op">(</span><span class="va">lognorm_st</span>, layer<span class="op">=</span><span class="st">"data"</span>, selection.method <span class="op">=</span> <span class="st">"vst"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Extract the top 15 most variable genes</span></span>
<span><span class="va">top15</span>        <span class="op">&lt;-</span> <span class="fu">head</span><span class="op">(</span><span class="fu">VariableFeatures</span><span class="op">(</span><span class="va">lognorm_st</span>, layer<span class="op">=</span><span class="st">"data"</span>, method<span class="op">=</span><span class="st">"vst"</span><span class="op">)</span>, <span class="fl">15</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Make a mean-variance plot of the log-transformed data</span></span>
<span><span class="va">plot_lognorm</span> <span class="op">&lt;-</span> <span class="fu">VariableFeaturePlot</span><span class="op">(</span><span class="va">lognorm_st</span><span class="op">)</span> <span class="op">+</span></span>
<span>                  <span class="fu">ggtitle</span><span class="op">(</span><span class="st">"Variable Features - Log normalization"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Add the names of the top 15 most variable genes</span></span>
<span><span class="va">plot_lognorm</span> <span class="op">&lt;-</span> <span class="fu">LabelPoints</span><span class="op">(</span>plot <span class="op">=</span> <span class="va">plot_lognorm</span>, points <span class="op">=</span> <span class="va">top15</span>, repel <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">plot_lognorm</span></span></code></pre>
</div>
<figure><img src="fig/apply-normalization-methods-rendered-unnamed-chunk-20-1.png" style="display: block; margin: auto;" class="figure mx-auto d-block"></figure><p>As with the standardized CPM values above, we have significantly
reduced the dependence of variance in gene expression on its mean – at
least at all but the highest end of the expression. By default, Seurat
selects a set of 2,000 variable genes which are colored in red. Note
that a majority of the highly variable genes, and all of the top 15 most
variable that we labeled, are peaked in a narrow range of high
expression values. We would not expect this <em>a priori</em>, and it
signals inadequate normalization.</p>
<p>Putting this concern aside for a moment, let’s look at the spatial,
normalized expression of the two most variable genes.</p>
<div class="codewrapper sourceCode" id="cb30">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Seurat's nomenclature is inconsistent. Here slot is the same as layer.</span></span>
<span><span class="fu">SpatialFeaturePlot</span><span class="op">(</span><span class="va">lognorm_st</span>, slot<span class="op">=</span><span class="st">"data"</span>, <span class="fu">c</span><span class="op">(</span><span class="st">"SCGB2A2"</span>, <span class="st">"PLP1"</span><span class="op">)</span><span class="op">)</span></span></code></pre>
</div>
<figure><img src="fig/apply-normalization-methods-rendered-unnamed-chunk-21-1.png" style="display: block; margin: auto;" class="figure mx-auto d-block"></figure><p>Both clearly show significant spatial variability – despite the fact
that we did not explicitly query for genes whose expression varied
spatially. We will look at approaches for doing that later, such as the
Moran’s I statistic. <i>PLP1</i> shows coherent spatial variability
closely linked to brain morphology – this is a marker for the white
matter. <i>SCGB2A2</i> also shows strong spatial variability, though it
does not appear to reflect the underlying neocortical layers. It should
not surprise us that there is spatially variable gene expression beyond
that caused by the (known) layered architecture of the brain. This is
one such example.</p>
<p>As a further sanity check that the normalization is doing something
sensible, let’s look at the expression of two, known layer-restricted
marker genes – <i>MOBP</i> and <i>PCP4</i>. <i>MOBP</i> is known to be
restricted to the white matter, while <i>PCP4</i> is expressed in Layer
5.</p>
<div class="codewrapper sourceCode" id="cb31">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">SpatialFeaturePlot</span><span class="op">(</span><span class="va">lognorm_st</span>, slot<span class="op">=</span><span class="st">"data"</span>, <span class="fu">c</span><span class="op">(</span><span class="st">"MOBP"</span>, <span class="st">"PCP4"</span><span class="op">)</span><span class="op">)</span></span></code></pre>
</div>
<figure><img src="fig/apply-normalization-methods-rendered-unnamed-chunk-22-1.png" style="display: block; margin: auto;" class="figure mx-auto d-block"></figure><p>Indeed, this is what we observe.</p>
</div>
<div class="section level4">
<h4 id="sctransform">SCTransform<a class="anchor" aria-label="anchor" href="#sctransform"></a>
</h4>
<p>Let’s see if we can improve on two aspects of the above
log-normalization: 1) the non-uniform standardized variance of highly
expressed genes and 2) the bias of highly variable genes towards highly
expressed genes. We will apply <a href="https://satijalab.org/seurat/articles/sctransform_vignette.html" class="external-link"><code>SCTransform</code></a>,
a normalization approach that uses a regularized negative binomial
regression to stabilize variance across expression levels (<a href="https://link.springer.com/article/10.1186/s13059-021-02584-9" class="external-link">Choudhary
et al., Genome Biol 23, 27 (2022)</a>).</p>
<div class="codewrapper sourceCode" id="cb32">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Apply SCTransform to the raw count data in the Spatial assay</span></span>
<span><span class="va">sct_st</span> <span class="op">&lt;-</span> <span class="fu">SCTransform</span><span class="op">(</span><span class="va">filter_st</span>, assay <span class="op">=</span> <span class="st">"Spatial"</span><span class="op">)</span></span></code></pre>
</div>
<p>The <code>SCTransform</code> method added a new assay called
<code>SCT</code>, as we can see below by assessing the assays of the
Seurat object:</p>
<div class="codewrapper sourceCode" id="cb33">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Access assays of the Seurat object</span></span>
<span><span class="fu">Assays</span><span class="op">(</span><span class="va">sct_st</span><span class="op">)</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>[1] "Spatial" "SCT"    </code></pre>
</div>
<p>It made this new assay the default. Be aware that Seurat functions
often operate on the <code>DefaultAssay</code>.</p>
<div class="codewrapper sourceCode" id="cb35">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Access the default assay of the Seurat object</span></span>
<span><span class="fu">DefaultAssay</span><span class="op">(</span><span class="va">sct_st</span><span class="op">)</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>[1] "SCT"</code></pre>
</div>
<p>Within this new <code>SCT</code> Assay, <code>SCTransform</code> has
created three <code>Layers</code> to store data, not to be confused with
the neocortical layers of the brain.</p>
<div class="codewrapper sourceCode" id="cb37">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Assess the layers of the default assay of the Seurat object</span></span>
<span><span class="fu">Layers</span><span class="op">(</span><span class="va">sct_st</span><span class="op">)</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>[1] "counts"     "data"       "scale.data"</code></pre>
</div>
<p>As you can see by reading the <code>SCTransform</code> documentation
with</p>
<div class="codewrapper sourceCode" id="cb39">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="op">?</span><span class="va">SCTransform</span></span></code></pre>
</div>
<p>these new <code>Layers</code> are <code>counts</code> (counts
corrected for differences in sequencing depth between cells),
<code>data</code> (<code>log1p</code> transformation of the corrected
counts), and <code>scale.data</code> (scaled Pearson residuals,
<em>i.e.</em>, the difference between an observed count and its expected
value under the model used by <code>SCTransform</code>, divided by the
standard deviation in that count under the model).</p>
<figure><img src="./fig/seurat_object_assays_layers.png" alt="A diagram of the sttructure of a Seurat object showing the assays (Spatial &amp; SCT) and Layers (counts, data &amp; scale.data." class="figure mx-auto d-block"><div class="figcaption">Seurat object structure</div>
</figure><p>Notice, in particular, that the <code>counts</code> Layers in the
<code>Spatial</code> and <code>SCT</code> Assays are different. As
mentioned above, the latter have been corrected for differences in
sequencing depth between cells. As such, the distribution in total
counts per cell is much more uniform in the latter case.</p>
<div class="codewrapper sourceCode" id="cb40">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Create a one-column plot with two panels</span></span>
<span><span class="fu">layout</span><span class="op">(</span><span class="fu">matrix</span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Extract the raw count data from the counts layer of the Spatial assay</span></span>
<span><span class="va">raw_counts_spatial</span> <span class="op">&lt;-</span> <span class="fu">LayerData</span><span class="op">(</span><span class="va">sct_st</span>, layer <span class="op">=</span> <span class="st">"counts"</span>, assay <span class="op">=</span> <span class="st">"Spatial"</span><span class="op">)</span></span>
<span><span class="co"># Plot a histogram of the total counts (column sum) of the raw counts</span></span>
<span><span class="fu">hist</span><span class="op">(</span><span class="fu">colSums2</span><span class="op">(</span><span class="va">raw_counts_spatial</span><span class="op">)</span>, main <span class="op">=</span> <span class="st">"Raw counts (Spatial)"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Extract the corrected counts from the data layer of the SCT assay</span></span>
<span><span class="va">corrected_counts_sct</span> <span class="op">&lt;-</span> <span class="fu">LayerData</span><span class="op">(</span><span class="va">sct_st</span>, layer <span class="op">=</span> <span class="st">"counts"</span>, assay <span class="op">=</span> <span class="st">"SCT"</span><span class="op">)</span></span>
<span><span class="co"># Plot a histogram of the total corrected counts (column sum)</span></span>
<span><span class="fu">hist</span><span class="op">(</span><span class="fu">colSums2</span><span class="op">(</span><span class="va">corrected_counts_sct</span><span class="op">)</span>, main <span class="op">=</span> <span class="st">"Corrected counts (SCT)"</span><span class="op">)</span></span></code></pre>
</div>
<figure><img src="fig/apply-normalization-methods-rendered-unnamed-chunk-28-1.png" style="display: block; margin: auto;" class="figure mx-auto d-block"></figure><p>Let’s plot the mean-variance relationship. Notice that SCTransform
implicitly computes variable features, so we do not need to explicitly
call FindVariableFeatures, as we did above.</p>
<div class="codewrapper sourceCode" id="cb41">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Extract the top 15 most variable genes, as computed from the SCTransformed data.</span></span>
<span><span class="va">top15SCT</span>    <span class="op">&lt;-</span> <span class="fu">head</span><span class="op">(</span><span class="fu">VariableFeatures</span><span class="op">(</span><span class="va">sct_st</span><span class="op">)</span>, <span class="fl">15</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Make a mean-variance plot of the SCTransformed data.</span></span>
<span><span class="va">plot_sct</span>    <span class="op">&lt;-</span> <span class="fu">VariableFeaturePlot</span><span class="op">(</span><span class="va">sct_st</span><span class="op">)</span> <span class="op">+</span> </span>
<span>                 <span class="fu">ggtitle</span><span class="op">(</span><span class="st">"Variable Features - SCT"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Add the names of the top 15 most variable genes.</span></span>
<span><span class="va">plot_sct</span>    <span class="op">&lt;-</span> <span class="fu">LabelPoints</span><span class="op">(</span>plot <span class="op">=</span> <span class="va">plot_sct</span>, points <span class="op">=</span> <span class="va">top15SCT</span>, repel <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">plot_sct</span></span></code></pre>
</div>
<figure><img src="fig/apply-normalization-methods-rendered-unnamed-chunk-29-1.png" style="display: block; margin: auto;" class="figure mx-auto d-block"></figure><p>Notice that VariableFeaturePlot outputs slightly different axes,
depending on the transformed data to display. In this case, for
SCTransformed data, it plots the geometric mean (mean of the log counts)
on the x axis and the “residual variance” on the y axis. “Residual
variance” is a confusing term; it refers to the variance in the Pearson
residuals, similar to the standardized variance we encountered
above.</p>
<p>We will compare this mean-variance plot to the one derived using
log-normalization below. Before we do, let’s look at the spatial
expression of the two most variable genes following SCTransform. One of
these, <i>PLP1</i>, we have already seen above.</p>
<div class="codewrapper sourceCode" id="cb42">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Plot the SCTransformed values (specifically, the log-transformed correct counts)</span></span>
<span><span class="co"># of the genes MBP and PLP1 spatially, by accessing the "data" slot (or layer). </span></span>
<span><span class="fu">SpatialFeaturePlot</span><span class="op">(</span><span class="va">sct_st</span>, slot<span class="op">=</span><span class="st">"data"</span>, <span class="fu">c</span><span class="op">(</span><span class="st">"MBP"</span>, <span class="st">"PLP1"</span><span class="op">)</span><span class="op">)</span></span></code></pre>
</div>
<figure><img src="fig/apply-normalization-methods-rendered-unnamed-chunk-30-1.png" style="display: block; margin: auto;" class="figure mx-auto d-block"></figure><p>Both genes have stunning spatially variable expresion. And, here,
that variability happens to reflect the underlying layered architecture
of the brain. As we noted above, it needn’t have been the case that
spatially variable genes are also layer restricted. That the top
variable genes following SCTransform are layer restricted, whereas only
one but not the other is following log normalization, should not in and
of itself imply that the former transformation is “better” than the
latter.</p>
<p>Let’s again check that the two marker genes show the appropriate
layer-restricted expression following normalization with
SCTransform.</p>
<div class="codewrapper sourceCode" id="cb43">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Plot the SCTransformed values (specifically, the log-transformed correct counts)</span></span>
<span><span class="co"># of the known marker genes MOBP and PCP4 spatially, by accessing the "data" slot (or layer). </span></span>
<span><span class="fu">SpatialFeaturePlot</span><span class="op">(</span><span class="va">sct_st</span>, slot<span class="op">=</span><span class="st">"data"</span>, <span class="fu">c</span><span class="op">(</span><span class="st">"MOBP"</span>, <span class="st">"PCP4"</span><span class="op">)</span><span class="op">)</span></span></code></pre>
</div>
<figure><img src="fig/apply-normalization-methods-rendered-unnamed-chunk-31-1.png" style="display: block; margin: auto;" class="figure mx-auto d-block"></figure><p>Indeed, they do. We conclude that SCTransform normalization looks
reasonable.</p>
<div id="challenge-1-compare-mean-variance-plots" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-1-compare-mean-variance-plots" class="callout-inner">
<h3 class="callout-title">Challenge 1: Compare Mean-Variance Plots</h3>
<div class="callout-content">
<p>Above, we created mean-variance plots for the SCTransform and log
normalizations. Which method does a better job of stabilizing the
variance across genes? Turn to the person next to you and put the
log-normalized plot on one of your screens and the SCTransform plot on
the other person’s screen. Discuss the mean-variance relationship in
each plot and decide which one you think stabilizes the variance across
genes better.</p>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Solution 1 </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" aria-labelledby="headingSolution1" data-bs-parent="#accordionSolution1">
<div class="accordion-body">
<p>We will compare the two plots in the next section.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="section level3">
<h3 id="comparing-normalizations">Comparing Normalizations<a class="anchor" aria-label="anchor" href="#comparing-normalizations"></a>
</h3>

<p>First, let’s look at the sum of the normalized expression values per
spot for each method. Recall from above that <code>NormalizeData</code>
put the log-transformed values in the <code>data</code> layer.
Similarly, <code>SCTransform</code> puts the log1p transformed values of
the corrected counts in the <code>data</code> layer. So, we access that
layer below.</p>
<div class="codewrapper sourceCode" id="cb44">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Create a one-column plot with two panels</span></span>
<span><span class="fu">layout</span><span class="op">(</span><span class="fu">matrix</span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Extract the log-normalized data from the data layer of the lognorm_st Seurat object</span></span>
<span><span class="va">sum_log</span> <span class="op">&lt;-</span> <span class="fu">LayerData</span><span class="op">(</span><span class="va">lognorm_st</span>, layer <span class="op">=</span> <span class="st">"data"</span><span class="op">)</span></span>
<span><span class="co"># Plot a histogram of the column sum of the log-normalized data</span></span>
<span><span class="fu">hist</span><span class="op">(</span><span class="fu">colSums2</span><span class="op">(</span><span class="va">sum_log</span><span class="op">)</span>, main <span class="op">=</span> <span class="st">"Log-norm"</span>, xlab <span class="op">=</span> <span class="st">"Summed, Normalized Expression Values"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Extract the SCTransformed (log-transformed corrected count) data from the data layer of the sct_st Seurat object</span></span>
<span><span class="va">sum_sct</span> <span class="op">&lt;-</span> <span class="fu">LayerData</span><span class="op">(</span><span class="va">sct_st</span>, layer <span class="op">=</span> <span class="st">"data"</span><span class="op">)</span></span>
<span><span class="co"># Plot a histogram of the column sum of the SCTransformed (log-transformed corrected count) data </span></span>
<span><span class="fu">hist</span><span class="op">(</span><span class="fu">colSums2</span><span class="op">(</span><span class="va">sum_sct</span><span class="op">)</span>, main <span class="op">=</span> <span class="st">"SCT"</span>, xlab <span class="op">=</span> <span class="st">"Summed, Normalized Expression Values"</span><span class="op">)</span></span></code></pre>
</div>
<figure><img src="fig/apply-normalization-methods-rendered-unnamed-chunk-32-1.png" style="display: block; margin: auto;" class="figure mx-auto d-block"></figure><p>Notice that the log-normalization has a range of summed expression
values per spot spanning several orders of magnitude. The SCTransform
has a more uniform distribution of summed normalized expression values
that spans a factor of three, from ~1000 to ~2700.</p>
<p>Next, we will compare the mean-variance plots between the two
methods.</p>
<div class="codewrapper sourceCode" id="cb45">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">plot_lognorm</span></span></code></pre>
</div>
<figure><img src="fig/apply-normalization-methods-rendered-unnamed-chunk-33-1.png" style="display: block; margin: auto;" class="figure mx-auto d-block"></figure><div class="codewrapper sourceCode" id="cb46">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">plot_sct</span></span></code></pre>
</div>
<figure><img src="fig/apply-normalization-methods-rendered-unnamed-chunk-33-2.png" style="display: block; margin: auto;" class="figure mx-auto d-block"></figure><p>Following SCTransform, the variance is largely stable across a range
of mean expression values. Certainly, we do not observe the wild ripple
in the mean-variance trend at the high expression end that we saw with
log-normalization. Secondly, the highly variable genes are spread across
a larger region and not overly biased towards the high end of the
expression spectrum.</p>
<p>We conclude that SCTransform is more appropriate for these data than
log normalization for those two reasons:</p>
<ul>
<li>The variance is stable throughout the entire range of mean
expression values, <em>i.e.</em>, the standardized variance is near one
throughout this range.</li>
<li>The highly variable genes, <em>i.e.</em>, those whose standardized
variance deviates from one, are spread throughout the expression
spectrum and not localized to highly expressed genes.</li>
</ul>
</div>
<div class="section level3">
<h3 id="no-one-size-fits-all-approach">No One-Size-Fits-All Approach<a class="anchor" aria-label="anchor" href="#no-one-size-fits-all-approach"></a>
</h3>
<p>Raw read counts provide essential insights into absolute cell
densities within a sample. In some cases, this may reflect
morphologically distinct regions and / or regions enriched for
particular cell types. We advise assessing raw gene and count spatial
distributions prior to normalization for this reason.</p>
<p>In this particular example, we found that SCTransform better
ameliorated the mean-variance trend than log-normalization. We make no
claim that this will hold universally across samples. Indeed, rather
than advocating for one particular normalization approach, our goal was
to introduce you to means of diagnosing the impact of normalization
methods and of comparing them.</p>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>Normalization is necessary to deal with technical artifacts, in
particular, varying total counts (library size) across spots and the
dependence of a gene’s variance on its mean expression.</li>
<li>Nevertheless, raw (unnormalized) data can provide biologically
meaningful insights such as region-specific differences in cell type or
density that impact total reads.</li>
<li>Popular methods aim to address these artifacts and include, but are
not limited to, CPM normalization, log normalization, and
SCTransform.</li>
<li>The ability of a normalization method to stabilize expression
variance across its mean (<em>i.e.</em>, to remove the dependence of the
former on the latter) can be assessed visually with a mean-variance
plot.</li>
</ul>
</div>
</div>
</div>
</div>
<div class="section level3">
<h3 id="where-we-are-headed">Where We Are Headed<a class="anchor" aria-label="anchor" href="#where-we-are-headed"></a>
</h3>
<p>Now that we have normalized away technical differences across spots,
we are poised for downstream analyses that will implicitly make
comparisons across them. These include dimensionality reduction and
clustering, which we will investigate next.</p>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div>
</section></section><section id="aio-feature-selection-dimensionality-reduction-clustering"><p>Content from <a href="feature-selection-dimensionality-reduction-clustering.html">Feature Selection, Dimensionality Reduction, and Spot Clustering</a></p>
<hr>
<p>Last updated on 2025-03-04 |

        <a href="https://github.com/smcclatchy/spatial-transcriptomics/edit/main/episodes/feature-selection-dimensionality-reduction-clustering.Rmd" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>Why is feature selection important in spatial transcriptomics?</li>
<li>What are the implications of using different proportions of highly
variable genes (HVGs) in data analysis?</li>
<li>Why is feature selection in spatial transcriptomics not typically
necessary with normalization techniques like SCTransform?</li>
<li>How do PCA and UMAP differ in their approach to dimensionality
reduction in spatial transcriptomics?</li>
<li>What advantages do linear methods like PCA offer before applying
nonlinear methods like UMAP?</li>
<li>How do these dimensionality reduction techniques impact downstream
analysis such as clustering and visualization?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Identify appropriate feature selection methods for different
normalization techniques in spatial transcriptomics.</li>
<li>Evaluate the effects of varying the proportion of highly variable
genes on the resolution of clustering and PCA outcomes.</li>
<li>Understand the rationale behind the dependency of feature selection
on specific normalization methods like NormalizeData.</li>
<li>Differentiate between linear and nonlinear dimensionality reduction
methods and their applications in spatial transcriptomics.</li>
<li>Implement PCA to preprocess data before applying UMAP to enhance
interpretability and structure recognition.</li>
<li>Assess the effectiveness of each method in revealing spatial and
molecular patterns within the data.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="understanding-the-morphology-of-your-tissue">Understanding the Morphology of your Tissue<a class="anchor" aria-label="anchor" href="#understanding-the-morphology-of-your-tissue"></a>
</h2>
<hr class="half-width">
<p>In any analysis, it is important that you understand the structure
and cell types in the tissue which you are analyzing. While it would be
ideal to have an unbiased analysis that uses normalizations and
clustering methods to automatically assign cell types and define tissue
structure, in practice we adjust these parameters based on the tissue
structure that we expect to find.</p>
</section><section><h2 class="section-heading" id="understanding-feature-selection-in-spatial-transcriptomics">Understanding Feature Selection in Spatial Transcriptomics<a class="anchor" aria-label="anchor" href="#understanding-feature-selection-in-spatial-transcriptomics"></a>
</h2>
<hr class="half-width">
<p>Feature selection in spatial transcriptomics is essential for
reducing the dimensionality of high-dimensional datasets, enhancing
model performance, and improving interpretability. This process is
crucial because it helps in minimizing computational demands, reducing
noise, and speeding up downstream analyses like clustering and principal
components analysis (PCA). By focusing on a subset of genes that show
significant variability or are biologically relevant, researchers can
achieve more robust and generalizable models, draw clearer conclusions,
and facilitate hypothesis testing.</p>
<div class="section level3">
<h3 id="choosing-feature-selection-methods">Choosing Feature Selection Methods<a class="anchor" aria-label="anchor" href="#choosing-feature-selection-methods"></a>
</h3>
<div class="section level4">
<h4 id="importance-of-high-variable-gene-selection">Importance of High Variable Gene Selection<a class="anchor" aria-label="anchor" href="#importance-of-high-variable-gene-selection"></a>
</h4>
<p>Feature selection methods such as variance stabilizing transformation
(VST) and mean-variance plotting are crucial for refining the dataset to
include genes that exhibit meaningful variability across different
spatial regions. These methods help focus on genes that are most
informative for downstream analyses like clustering and dimensionality
reduction.</p>
</div>
</div>
<div class="section level3">
<h3 id="feature-selection-with-normalizedata">Feature Selection with <code>NormalizeData</code>
<a class="anchor" aria-label="anchor" href="#feature-selection-with-normalizedata"></a>
</h3>
<p>When using normalization methods like <code>NormalizeData</code>,
which focuses on scaling gene expression data without variance
stabilization, applying feature selection becomes essential. This method
requires the selection of highly variable genes to enhance the analysis,
particularly in clustering and PCA. Typically, you will select in the
range of 2,000 to 5,000 highly variable genes.</p>
</div>
<div class="section level3">
<h3 id="feature-selection-with-sctransform">Feature Selection with <code>SCTransform</code>
<a class="anchor" aria-label="anchor" href="#feature-selection-with-sctransform"></a>
</h3>
<p><code>SCTransform</code>, a normalization method, adjusts gene
expression data to stabilize the variance, and it also provides default
feature selection. This method ensures that the genes retained are
already adjusted for technical variability, highlighting those with
biological significance.</p>
<p>The <code>SCTransform</code> selects 3,000 variable features by
default. We will use those variable features to calculate <em>principal
components</em> (PCs) of the gene expression data. As always, we must
first scale (or standardize) the normalized counts data.</p>
<div id="challenge-1-number-of-variable-genes" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-1-number-of-variable-genes" class="callout-inner">
<h3 class="callout-title">Challenge 1: Number of Variable Genes</h3>
<div class="callout-content">
<p>How do you think that your results would be affected by selecting too
few highly variable genes? What about too many highly variable
genes?</p>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" aria-labelledby="headingSolution1" data-bs-parent="#accordionSolution1">
<div class="accordion-body">
<p>Too few variable genes may underestimate the variance between spots
and tissue sections and would reduce our ability to discern tissue
structure. Too many variable genes would increase computational time and
might add noise to the analysis.</p>
</div>
</div>
</div>
</div>
</div>
<div class="section level3">
<h3 id="dimensionality-reduction-using-principal-components">Dimensionality Reduction using Principal Components<a class="anchor" aria-label="anchor" href="#dimensionality-reduction-using-principal-components"></a>
</h3>
<p>Dimensionality reduction is a crucial step in managing
high-dimensional spatial transcriptomics data, enhancing analytical
clarity, and reducing computational load. Linear methods like PCA and
nonlinear methods like UMAP each play distinct roles in processing and
interpreting complex datasets.</p>
<p>PCA is a linear technique that reduces dimensionality by transforming
data into a set of uncorrelated variables called <em>principal
components</em> (PCs). This method efficiently captures the main
variance in the data, which is vital for preliminary data exploration
and noise reduction.</p>
<p>In order to cluster the spots by similarity, we use PCs to reduce the
number of dimensions in the data. Using a smaller number of PCs allows
us to capture the variability in the dataset while using a smaller
number of dimensions. The PCs are then used to cluster the spots by
similarity.</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">sct_st</span> <span class="op">&lt;-</span> <span class="fu">ScaleData</span><span class="op">(</span><span class="va">sct_st</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>               <span class="fu">RunPCA</span><span class="op">(</span>npcs <span class="op">=</span> <span class="fl">75</span>, verbose <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>Centering and scaling data matrix</code></pre>
</div>
<p>In the command above, we specifically asked Seurat to calculate 75
principal components. There are thousands of genes and we know that we
don’t need to calculate all PCs. By default, the <a href="https://satijalab.org/seurat/reference/runpca" class="external-link"><code>RunPCA</code></a>
method calculates 50 PCs. Let’s make an elbow plot of the number of PCs
versus the standard deviation explained by each PC. Traditionally, there
is a bend in the curve which indicates that adding more PCs doesn’t
account for more of the variance.</p>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">ElbowPlot</span><span class="op">(</span><span class="va">sct_st</span>, ndims <span class="op">=</span> <span class="fl">75</span><span class="op">)</span></span></code></pre>
</div>
<figure><img src="fig/feature-selection-dimensionality-reduction-clustering-rendered-unnamed-chunk-3-1.png" style="display: block; margin: auto;" class="figure mx-auto d-block"></figure><p>From the plot above, we would normally select somewhere between 10
and 20 PCs because there seems to be little benefit in adding more PCs.
Adding more PCs does not seem to add more explanatory variance.</p>
<p>But in spatial transcriptomics, the elbow plot often does not tell
the whole story. We want to select a number of PCs such that we are able
to discern the structure and cell type composition of our tissue. So it
is better to try a range of number of PCs.</p>
<p>For now, let’s use all 75 PCs.</p>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">n_pcs</span> <span class="op">=</span> <span class="fl">75</span></span></code></pre>
</div>
<p>In the next step, we will cluster the spots based on expression
similarity using the principal components that we just generated. We
will use Seurat’s <a href="https://satijalab.org/seurat/reference/findneighbors" class="external-link"><code>FindNeighbors</code></a>
and <a href="https://satijalab.org/seurat/reference/findclusters" class="external-link"><code>FindClusters</code></a>
functions. <code>FindNeighbors</code> find the K nearest neighbors of
each spot in the dataset. The default values is to use the 20 nearest
neighbors in the dataset and we will use this value in this lesson.
However, as with the number of features used to create the PCs, this is
another parameter that is worth varying before proceeding with your
analysis.</p>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">sct_st</span> <span class="op">&lt;-</span> <span class="fu">FindNeighbors</span><span class="op">(</span><span class="va">sct_st</span>, </span>
<span>                        reduction <span class="op">=</span> <span class="st">"pca"</span>, </span>
<span>                        dims      <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="va">n_pcs</span><span class="op">)</span> <span class="op">%&gt;%</span> </span>
<span>               <span class="fu">FindClusters</span><span class="op">(</span>resolution <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>Computing nearest neighbor graph</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>Computing SNN</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck

Number of nodes: 3633
Number of edges: 198594

Running Louvain algorithm...
Maximum modularity in 10 random starts: 0.7227
Number of communities: 9
Elapsed time: 0 seconds</code></pre>
</div>
<p>The clustering has added a new column to the spot metadata in the
Seurat object called <code>seurat_clusters</code>. Let’s look the
metadata to see this.</p>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">head</span><span class="op">(</span><span class="va">sct_st</span><span class="op">[[</span><span class="op">]</span><span class="op">]</span><span class="op">)</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>                      orig.ident nCount_Spatial nFeature_Spatial in_tissue
AAACAAGTATCTCCCA-1 SeuratProject           8458             3586         1
AAACAATCTACTAGCA-1 SeuratProject           1667             1150         1
AAACACCAATAACTGC-1 SeuratProject           3769             1960         1
AAACAGAGCGACTCCT-1 SeuratProject           5433             2424         1
AAACAGCTTTCAGAAG-1 SeuratProject           4278             2264         1
AAACAGGGTCTATATT-1 SeuratProject           4004             2178         1
                   array_row array_col pxl_row_in_fullres pxl_col_in_fullres
AAACAAGTATCTCCCA-1        50       102               8468               9791
AAACAATCTACTAGCA-1         3        43               2807               5769
AAACACCAATAACTGC-1        59        19               9505               4068
AAACAGAGCGACTCCT-1        14        94               4151               9271
AAACAGCTTTCAGAAG-1        43         9               7583               3393
AAACAGGGTCTATATT-1        47        13               8064               3665
                   percent.mt keep layer_guess cell_count nCount_SCT
AAACAAGTATCTCCCA-1   16.63514 TRUE      Layer3          6       5167
AAACAATCTACTAGCA-1   12.23755 TRUE      Layer1         16       3404
AAACACCAATAACTGC-1   11.40886 TRUE          WM          5       3828
AAACAGAGCGACTCCT-1   24.22234 TRUE      Layer3          2       4683
AAACAGCTTTCAGAAG-1   15.21739 TRUE      Layer5          4       4228
AAACAGGGTCTATATT-1   15.50949 TRUE      Layer6          6       3991
                   nFeature_SCT SCT_snn_res.1 seurat_clusters
AAACAAGTATCTCCCA-1         3192             0               0
AAACAATCTACTAGCA-1         1264             2               2
AAACACCAATAACTGC-1         1941             7               7
AAACAGAGCGACTCCT-1         2393             6               6
AAACAGCTTTCAGAAG-1         2239             5               5
AAACAGGGTCTATATT-1         2148             3               3</code></pre>
</div>
<p>We previously discussed the layer annotations provided by Maynard and
colleagues. We added them to our Seurat object and plotted them. Let’s
look at them again to compare them to our clusters.</p>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">SpatialDimPlotColorSafe</span><span class="op">(</span><span class="va">sct_st</span><span class="op">[</span>, <span class="op">!</span><span class="fu">is.na</span><span class="op">(</span><span class="va">sct_st</span><span class="op">[[</span><span class="op">]</span><span class="op">]</span><span class="op">$</span><span class="va">layer_guess</span><span class="op">)</span><span class="op">]</span>, <span class="st">"layer_guess"</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">labs</span><span class="op">(</span>fill<span class="op">=</span><span class="st">"Layer"</span><span class="op">)</span> </span></code></pre>
</div>
<figure><img src="fig/feature-selection-dimensionality-reduction-clustering-rendered-unnamed-chunk-7-1.png" style="display: block; margin: auto;" class="figure mx-auto d-block"></figure><p>The authors describe six layers arranged from the upper right to the
lower left, and a white matter (WM) later. At this stage of the
analysis, we have nine clusters, but they do not show the clear
separation of the ground truth in the source publication.</p>
<p>We will now plot the spots in the tissue, colored by the clusters
which we have identified in <code>seurat_clusters</code> to evaluate the
quality of the cluster identities by looking for the clarity of the
stripes forming each layer.</p>
<div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">SpatialDimPlotColorSafe</span><span class="op">(</span><span class="va">sct_st</span>, <span class="st">"seurat_clusters"</span><span class="op">)</span> <span class="op">+</span> <span class="fu">labs</span><span class="op">(</span>fill<span class="op">=</span><span class="st">"Cluster"</span><span class="op">)</span> </span></code></pre>
</div>
<figure><img src="fig/feature-selection-dimensionality-reduction-clustering-rendered-unnamed-chunk-8-1.png" style="display: block; margin: auto;" class="figure mx-auto d-block"></figure><p>How many layers do we have compared to the publication? What do you
think about the quality of the layers in this plot? Are there clear
layers in the tissue?</p>
<p>Another way for us to look at the clusters it to plot them in a
Uniform Manifold Approximation and Projection (UMAP). UMAP is a
non-linear dimension reduction technique that can be used to visualize
data. This is often used in single-cell RNASeq to identify different
cell types. Here, each spot is potentially composed of more than one
cell type, so the clustering may not be as clear.</p>
<div class="codewrapper sourceCode" id="cb13">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">num_clusters</span> <span class="op">&lt;-</span> <span class="fu">length</span><span class="op">(</span><span class="fu">unique</span><span class="op">(</span><span class="va">sct_st</span><span class="op">[[</span><span class="op">]</span><span class="op">]</span><span class="op">$</span><span class="va">seurat_clusters</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">color_pal</span>    <span class="op">&lt;-</span> <span class="fu">setNames</span><span class="op">(</span><span class="fu">carto_pal</span><span class="op">(</span><span class="va">num_clusters</span>, <span class="st">"Safe"</span><span class="op">)</span>, <span class="fl">0</span><span class="op">:</span><span class="op">(</span><span class="va">num_clusters</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="va">sct_st</span> <span class="op">&lt;-</span> <span class="fu">RunUMAP</span><span class="op">(</span><span class="va">sct_st</span>, </span>
<span>                  reduction <span class="op">=</span> <span class="st">'pca'</span>, </span>
<span>                  dims      <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="va">n_pcs</span>, </span>
<span>                  verbose   <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">UMAPPlot</span><span class="op">(</span><span class="va">sct_st</span>, </span>
<span>         label      <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>         cols       <span class="op">=</span> <span class="va">color_pal</span>,</span>
<span>         pt.size    <span class="op">=</span> <span class="fl">2</span>,</span>
<span>         label.size <span class="op">=</span> <span class="fl">6</span><span class="op">)</span></span></code></pre>
</div>
<figure><img src="fig/feature-selection-dimensionality-reduction-clustering-rendered-unnamed-chunk-9-1.png" style="display: block; margin: auto;" class="figure mx-auto d-block"></figure><p>We have made some decisions above which might affect the quality of
our spot clusters, including the number of nearest neighbors, the number
of variable features, the number of PCs, and the cluster resolution. As
we have mentioned, it is critical to have some understanding of the
structure of the tissue that you are analyzing. In the absence of
“ground truth”, you will need to try several different parameters and
look at how the clusters group in your tissue. Below, we have included
code which plots the tissue with different numbers of nearest neighbors,
principal components, and cluster resolutions. We will not run this code
because it takes a long time to run, but we show the output below this
code block.</p>
<div class="codewrapper sourceCode" id="cb14">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Set several cluster resolution values.</span></span>
<span><span class="va">resol</span> <span class="op">&lt;-</span> <span class="fu">c</span><span class="op">(</span><span class="fl">0.5</span>, <span class="fl">1</span>, <span class="fl">2</span><span class="op">)</span></span>
<span><span class="co"># Set several numbers of principal components.</span></span>
<span><span class="va">npcs</span>  <span class="op">&lt;-</span> <span class="fu">c</span><span class="op">(</span><span class="fl">25</span>, <span class="fl">50</span>, <span class="fl">75</span><span class="op">)</span></span>
<span></span>
<span><span class="va">num_clusters</span> <span class="op">&lt;-</span> <span class="fl">12</span></span>
<span><span class="va">color_pal</span>    <span class="op">&lt;-</span> <span class="fu">setNames</span><span class="op">(</span><span class="fu">carto_pal</span><span class="op">(</span><span class="va">num_clusters</span>, <span class="st">"Safe"</span><span class="op">)</span>, <span class="fl">0</span><span class="op">:</span><span class="op">(</span><span class="va">num_clusters</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="va">umap_plots</span> <span class="op">&lt;-</span> <span class="fu">vector</span><span class="op">(</span><span class="st">'list'</span>, <span class="fu">length</span><span class="op">(</span><span class="va">resol</span><span class="op">)</span> <span class="op">*</span> <span class="fu">length</span><span class="op">(</span><span class="va">npcs</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">plots</span>      <span class="op">&lt;-</span> <span class="fu">vector</span><span class="op">(</span><span class="st">'list'</span>, <span class="fu">length</span><span class="op">(</span><span class="va">resol</span><span class="op">)</span> <span class="op">*</span> <span class="fu">length</span><span class="op">(</span><span class="va">npcs</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fu">seq_along</span><span class="op">(</span><span class="va">resol</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="kw">for</span><span class="op">(</span><span class="va">j</span> <span class="kw">in</span> <span class="fu">seq_along</span><span class="op">(</span><span class="va">npcs</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span></span>
<span>    <span class="va">index</span>     <span class="op">&lt;-</span> <span class="op">(</span><span class="va">i</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span> <span class="op">*</span> <span class="fu">length</span><span class="op">(</span><span class="va">npcs</span><span class="op">)</span> <span class="op">+</span> <span class="va">j</span></span>
<span>    <span class="fu">print</span><span class="op">(</span><span class="fu">paste</span><span class="op">(</span><span class="st">'Index ='</span>, <span class="va">index</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span>    <span class="va">sct_st</span> <span class="op">&lt;-</span> <span class="fu">FindNeighbors</span><span class="op">(</span><span class="va">sct_st</span>, </span>
<span>                            reduction <span class="op">=</span> <span class="st">"pca"</span>, </span>
<span>                            dims      <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="va">npcs</span><span class="op">[</span><span class="va">j</span><span class="op">]</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>                   <span class="fu">FindClusters</span><span class="op">(</span>resolution <span class="op">=</span> <span class="va">resol</span><span class="op">[</span><span class="va">i</span><span class="op">]</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>                   <span class="fu">RunUMAP</span><span class="op">(</span>reduction <span class="op">=</span> <span class="st">'pca'</span>, </span>
<span>                           dims      <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="va">npcs</span><span class="op">[</span><span class="va">j</span><span class="op">]</span>,</span>
<span>                           verbose   <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span></span>
<span>    <span class="va">umap_plots</span><span class="op">[[</span><span class="va">index</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu">UMAPPlot</span><span class="op">(</span><span class="va">sct_st</span>, label <span class="op">=</span> <span class="cn">TRUE</span>, cols <span class="op">=</span> <span class="va">color_pal</span>, </span>
<span>                                    pt.size <span class="op">=</span> <span class="fl">2</span>, label.size <span class="op">=</span> <span class="fl">4</span><span class="op">)</span> <span class="op">+</span></span>
<span>                             <span class="fu">ggtitle</span><span class="op">(</span><span class="fu">paste</span><span class="op">(</span><span class="st">"res ="</span>, <span class="va">resol</span><span class="op">[</span><span class="va">i</span><span class="op">]</span>, <span class="st">": pc ="</span>, <span class="va">npcs</span><span class="op">[</span><span class="va">j</span><span class="op">]</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span></span>
<span>                             <span class="fu">theme</span><span class="op">(</span>legend.position <span class="op">=</span> <span class="st">"none"</span><span class="op">)</span></span>
<span></span>
<span>    <span class="va">plots</span><span class="op">[[</span><span class="va">index</span><span class="op">]</span><span class="op">]</span>      <span class="op">&lt;-</span> <span class="fu">SpatialDimPlot</span><span class="op">(</span><span class="va">sct_st</span>, </span>
<span>                                          group.by <span class="op">=</span> <span class="st">"seurat_clusters"</span>, </span>
<span>                                          cols <span class="op">=</span> <span class="va">color_pal</span><span class="op">)</span> <span class="op">+</span></span>
<span>                          <span class="fu">ggtitle</span><span class="op">(</span><span class="fu">paste</span><span class="op">(</span><span class="st">"res ="</span>, <span class="va">resol</span><span class="op">[</span><span class="va">i</span><span class="op">]</span>, <span class="st">": pc ="</span>, <span class="va">npcs</span><span class="op">[</span><span class="va">j</span><span class="op">]</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span> </span>
<span>                          <span class="fu">theme</span><span class="op">(</span>legend.position <span class="op">=</span> <span class="st">"none"</span><span class="op">)</span></span>
<span></span>
<span>  <span class="op">}</span> <span class="co"># for(j)</span></span>
<span></span>
<span><span class="op">}</span> <span class="co"># for(i)</span></span>
<span></span>
<span><span class="fu">png</span><span class="op">(</span><span class="fu">file.path</span><span class="op">(</span><span class="st">'episodes'</span>, <span class="st">'fig'</span>, <span class="st">'tissue_cluster_resol.png'</span><span class="op">)</span>,</span>
<span>    width <span class="op">=</span> <span class="fl">1000</span>, height <span class="op">=</span> <span class="fl">1000</span>, res <span class="op">=</span> <span class="fl">128</span><span class="op">)</span></span>
<span><span class="fu">print</span><span class="op">(</span><span class="fu">gridExtra</span><span class="fu">::</span><span class="fu">grid.arrange</span><span class="op">(</span>grobs <span class="op">=</span> <span class="va">plots</span>, nrow <span class="op">=</span> <span class="fl">3</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu">dev.off</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">png</span><span class="op">(</span><span class="fu">file.path</span><span class="op">(</span><span class="st">'episodes'</span>, <span class="st">'fig'</span>, <span class="st">'umap_cluster_resol.png'</span><span class="op">)</span>,</span>
<span>    width <span class="op">=</span> <span class="fl">1000</span>, height <span class="op">=</span> <span class="fl">1000</span>, res <span class="op">=</span> <span class="fl">128</span><span class="op">)</span></span>
<span><span class="fu">print</span><span class="op">(</span><span class="fu">gridExtra</span><span class="fu">::</span><span class="fu">grid.arrange</span><span class="op">(</span>grobs <span class="op">=</span> <span class="va">umap_plots</span>, nrow <span class="op">=</span> <span class="fl">3</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu">dev.off</span><span class="op">(</span><span class="op">)</span></span></code></pre>
</div>
<p>The plot below shows the clusters as colors overlayed on the tissue.
Each row shows a different cluster resolution and each column shows the
number of PCs.</p>
<figure><img src="fig/tissue_cluster_resol.png" alt="Tissue Clustering showing the tissue layers at different resolutions and number of PCs" class="figure mx-auto d-block"><div class="figcaption">Tissue Clustering with Different Numbers of PCs
and Clustering Resolutions</div>
</figure><p>The plot below shows the UMAP clustering for the same set of
parameters in the same order. The cluster colors are the same in the
plots above and below. Increasing the cluster resolution increases the
number of clusters.</p>
<figure><img src="fig/umap_cluster_resol.png" alt="UMAP Clustering with Different Numbers of PCs and Clustering Resolutions" class="figure mx-auto d-block"><div class="figcaption">UMAP Clustering with Different Numbers of PCs
and Clustering Resolutions</div>
</figure><div id="challenge-1-select-cluster-resolution-and-number-of-pcs" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-1-select-cluster-resolution-and-number-of-pcs" class="callout-inner">
<h3 class="callout-title">Challenge 1: Select cluster resolution and number of PCs</h3>
<div class="callout-content">
<p>Look at the two plots above which show the tissue and UMAP clusters
at different cluster resolutions and number of PCs. Think about which
settings seem to produce clustering that matches the expectations from
the publication. Turn to the person next to you and discuss your
opinions about which settings to use.</p>
</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2"> Solution 1 </h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" aria-labelledby="headingSolution2" data-bs-parent="#accordionSolution2">
<div class="accordion-body">
<p>All of the plots in the tissue clustering show layers which broadly
conform to the publication’s “ground truth.” In the top row at a
resolution of 0.5, we see about four layers with varying levels of
clarity, depending on the number of PCs. As we move down in the tissue
clustering plot, the layers become clearer at a resolution of 1, but
then become less clear at a resolution of 2 in the bottom row. When we
look at the corresponding row in the UMAP plots, we see that the white
matter is clearly separated in all of the plots. The number of clusters
increases with increasing cluster resolution, with the middle row
(cluster resolution = 1), having close to seven layers, like the
publication ground truth. The middle plot in the middle row has nine
clusters, which is also close to the publication.</p>
</div>
</div>
</div>
</div>
<p>We selected a cluster resolution of 0.8 and 50 PCs for the following
work.</p>
<div class="codewrapper sourceCode" id="cb15">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">sct_st</span> <span class="op">&lt;-</span> <span class="fu">FindNeighbors</span><span class="op">(</span><span class="va">sct_st</span>, </span>
<span>                        reduction <span class="op">=</span> <span class="st">"pca"</span>, </span>
<span>                        dims      <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fl">50</span><span class="op">)</span> <span class="op">%&gt;%</span> </span>
<span>               <span class="fu">FindClusters</span><span class="op">(</span>resolution <span class="op">=</span> <span class="fl">0.8</span><span class="op">)</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck

Number of nodes: 3633
Number of edges: 175530

Running Louvain algorithm...
Maximum modularity in 10 random starts: 0.7508
Number of communities: 8
Elapsed time: 0 seconds</code></pre>
</div>
<div class="codewrapper sourceCode" id="cb17">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">SpatialDimPlotColorSafe</span><span class="op">(</span><span class="va">sct_st</span>, <span class="st">"seurat_clusters"</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">ggtitle</span><span class="op">(</span>label <span class="op">=</span> <span class="st">"Tissue Clusters: 50 PCs, resol = 0.8"</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">labs</span><span class="op">(</span>fill <span class="op">=</span> <span class="st">"Cluster"</span><span class="op">)</span></span></code></pre>
</div>
<figure><img src="fig/feature-selection-dimensionality-reduction-clustering-rendered-unnamed-chunk-12-1.png" style="display: block; margin: auto;" class="figure mx-auto d-block"></figure><div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>Feature selection is a crucial step in spatial transcriptomics
analysis, particularly for non-variance-stabilizing normalization
methods like <code>NormalizeData</code>.</li>
<li>Techniques such as VST and mean-variance plotting enable researchers
to focus on genes that provide the most biological insight.</li>
<li>Different proportions of highly variable genes and feature selection
methods can significantly influence the analytical outcomes, emphasizing
the need for tailored approaches based on the specific characteristics
of each dataset.</li>
<li>Linear dimensionality reduction methods like PCA are crucial for
initial data simplification and noise reduction.</li>
<li>Nonlinear methods like UMAP are valuable for detailed exploration of
data structures post-linear preprocessing.</li>
<li>The sequential application of PCA and UMAP can provide a
comprehensive view of the spatial transcriptomics data, leveraging the
strengths of both linear and nonlinear approaches.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div>
</section></section><section id="aio-deconvolve-cell-types-in-a-spot"><p>Content from <a href="deconvolve-cell-types-in-a-spot.html">Deconvolution in Spatial Transcriptomics</a></p>
<hr>
<p>Last updated on 2025-03-04 |

        <a href="https://github.com/smcclatchy/spatial-transcriptomics/edit/main/episodes/deconvolve-cell-types-in-a-spot.Rmd" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>How can we bring single-cell resolution to multi-cellular spatial
transcriptomics spots?</li>
<li>What are different algorithmic approaches for doing so?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Explain spot deconvolution.</li>
<li>Perform deconvolution to quantify different cell types in spatial
transcriptomics spots using a supervised approach that employs scRNA-seq
data.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="deconvolution-in-spatial-transcriptomics">Deconvolution in Spatial Transcriptomics<a class="anchor" aria-label="anchor" href="#deconvolution-in-spatial-transcriptomics"></a>
</h2>
<hr class="half-width">
<p>Each spatial spot in an ST experiment generally contains multiple
cells. For example, spots in the Visium assay are 55 microns in
diameter, whereas a typical T cell has a diameter of ~10 microns. As
such, the expression read out from the spot mixes together the
expression of the individual cells encompassed by it. Deconvolution is
the approach for unmixing this combined expression signal. Most often,
deconvolution methods predict the fraction of each spot’s expression
derived from each particular cell type. Supervised methods deconvolve
spot expression using cell type expression profiles (<em>e.g.</em>, from
scRNA-seq) or marker genes. Therefore, we will need a prior knowledge or
data for these methods. Unsupervised approaches instead infer the
expression of the cell types without using priori information about cell
types.</p>
<p><img src="https://ars.els-cdn.com/content/image/1-s2.0-S200103702200558X-ga1_lrg.jpg" alt="alt text for accessibility purposes" class="figure"><a href="https://www.sciencedirect.com/science/article/pii/S200103702200558X#f0015" class="external-link">Zhang
et al, Comput Struct Biotechnol J 21, 176–184 (2023)</a>
<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" rel="license" class="external-link">CC
BY-NC-ND 4.0</a></p>
</section><section><h2 class="section-heading" id="deconvolution-with-robust-cell-type-decomposition-rctd">Deconvolution with Robust Cell Type Decomposition (RCTD)<a class="anchor" aria-label="anchor" href="#deconvolution-with-robust-cell-type-decomposition-rctd"></a>
</h2>
<hr class="half-width">
<p>We will deconvolve spots by applying Robust Cell Type Decomposition
(RCTD; <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC8606190" class="external-link">Cable, D.
M., et al., Nature Biotechnology, 2021</a>), which is implemented in the
<a href="https://github.com/dmcable/spacexr" class="external-link"><code>spacexr</code></a>
package. The algorithm uses scRNA-seq data as a reference to deconvolve
the spatial transcriptomics data, estimating the proportions of
different cell types in each spatial spot. This method is considered
supervised method since we are using a prior knowledge about this
dataset. RCTD models the observed gene expression in each spatial spot
as a mixture of the gene expression profiles of different cell types,
where the estimated proportions are the coefficients of the expression
profiles in a linear model. Its procedure guarantees the
<em>estimated</em> proportions are non-negative, but note that they sum
to one. RCTD can operate in several modes: in <code>doublet</code> mode
it fits at most two cell types per spot, in <code>full</code> mode it
fits potentially all cell types in the reference per spot, and in
<code>multi</code> mode it again fits more than two cell types per spot
by extending the <code>doublet</code> approach. Here, we will use
<code>full</code> mode.</p>
</section><section><h2 class="section-heading" id="loading-scrna-seq-reference-data">Loading scRNA-seq reference data<a class="anchor" aria-label="anchor" href="#loading-scrna-seq-reference-data"></a>
</h2>
<hr class="half-width">
<p>First, we load the scRNA-seq data that will serve as a reference for
deconvolution. Individual cells are assumed to be annotated according to
their type. RCTD will use these cell type-specific expression profiles
to deconvolve each spot’s expression. Please note the use of <a href="https://www.rdocumentation.org/packages/data.table/versions/1.15.4/topics/fread" class="external-link"><code>fread</code></a>
from the data.table package. This provides an efficient means of loading
large data tables in csv and tsv format.</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># # Load scRNA-seq data</span></span>
<span><span class="va">sc.counts</span> <span class="op">&lt;-</span> <span class="fu">fread</span><span class="op">(</span><span class="st">"data/scRNA-seq/sc_counts.tsv.gz"</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>               <span class="fu">column_to_rownames</span><span class="op">(</span><span class="st">'V1'</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>               <span class="fu">as.matrix</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Load cell type annotations</span></span>
<span><span class="va">sc.metadata</span>   <span class="op">&lt;-</span> <span class="fu">read.delim</span><span class="op">(</span><span class="st">"data/scRNA-seq/sc_cell_types.tsv"</span><span class="op">)</span></span>
<span><span class="va">sc.cell.types</span> <span class="op">&lt;-</span> <span class="fu">setNames</span><span class="op">(</span><span class="fu">factor</span><span class="op">(</span><span class="va">sc.metadata</span><span class="op">$</span><span class="va">Value</span><span class="op">)</span>, <span class="va">sc.metadata</span><span class="op">$</span><span class="va">Name</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Verify that the barcodes in counts and cell types match.</span></span>
<span><span class="fu">stopifnot</span><span class="op">(</span><span class="fu">colnames</span><span class="op">(</span><span class="va">sc.counts</span><span class="op">)</span> <span class="op">==</span> <span class="fu">names</span><span class="op">(</span><span class="va">sc.cell.types</span><span class="op">)</span><span class="op">)</span></span></code></pre>
</div>
<p>Next, we will create the reference object encapsulating this
scRNA-seq data. We will use the <a href="https://rdrr.io/github/dmcable/RCTD/man/Reference.html" class="external-link"><code>Reference</code></a>
function, which will organize and store the scRNA-seq data for the next
steps.</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">sc_reference</span> <span class="op">&lt;-</span> <span class="fu">Reference</span><span class="op">(</span><span class="va">sc.counts</span>, <span class="va">sc.cell.types</span><span class="op">)</span></span></code></pre>
</div>
</section><section><h2 class="section-heading" id="applying-rctd-for-spot-deconvolution">Applying RCTD for spot deconvolution<a class="anchor" aria-label="anchor" href="#applying-rctd-for-spot-deconvolution"></a>
</h2>
<hr class="half-width">
<p>Let’s write a wrapper function that performs RCTD deconvolution. This
will facilitate running RCTD on other samples within this dataset. It
calls <a href="https://rdrr.io/github/dmcable/RCTD/man/SpatialRNA.html" class="external-link"><code>SpatialRNA</code></a>
to create an object representing the ST data, much as we did for the
scRNA-seq data with <code>Reference</code> above. It then links the ST
and scRNA-seq in an RCTD object created with <a href="https://rdrr.io/github/dmcable/RCTD/man/create.RCTD.html" class="external-link"><code>create.RCTD</code></a>
and finally performs deconvolution by calling <a href="https://rdrr.io/github/dmcable/RCTD/man/run.RCTD.html" class="external-link"><code>run.RCTD</code></a>.</p>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Write the wrapper function which takes the "reference" built above and calculates cell type propotions for current dataset, st.obj</span></span>
<span><span class="va">run.rctd</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">reference</span>, <span class="va">st.obj</span><span class="op">)</span> <span class="op">{</span></span>
<span>  </span>
<span>  <span class="co"># Get raw ST counts</span></span>
<span>  <span class="va">st.counts</span> <span class="op">&lt;-</span> <span class="fu">GetAssayData</span><span class="op">(</span><span class="va">st.obj</span>, assay <span class="op">=</span> <span class="st">"Spatial"</span>, layer <span class="op">=</span> <span class="st">"counts"</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co"># Get the spot coordinates</span></span>
<span>  <span class="va">st.coords</span>           <span class="op">&lt;-</span> <span class="va">st.obj</span><span class="op">[[</span><span class="op">]</span><span class="op">]</span><span class="op">[</span>, <span class="fu">c</span><span class="op">(</span><span class="st">"array_col"</span>, <span class="st">"array_row"</span><span class="op">)</span><span class="op">]</span></span>
<span>  <span class="fu">colnames</span><span class="op">(</span><span class="va">st.coords</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu">c</span><span class="op">(</span><span class="st">"x"</span>,<span class="st">"y"</span><span class="op">)</span></span>
<span>    </span>
<span>  <span class="co"># Create the RCTD 'puck', representing the ST data</span></span>
<span>  <span class="va">puck</span>   <span class="op">&lt;-</span> <span class="fu">SpatialRNA</span><span class="op">(</span><span class="va">st.coords</span>, <span class="va">st.counts</span><span class="op">)</span></span>
<span></span>
<span>  <span class="va">myRCTD</span> <span class="op">&lt;-</span> <span class="fu">create.RCTD</span><span class="op">(</span><span class="va">puck</span>, <span class="va">reference</span>, max_cores <span class="op">=</span> <span class="fl">1</span>, </span>
<span>                        keep_reference <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span></span>
<span>  <span class="co"># Run deconvolution -- note that we are using 'full' mode to devolve a spot </span></span>
<span>  <span class="co"># into (potentially) all available cell types.</span></span>
<span>  <span class="va">myRCTD</span> <span class="op">&lt;-</span> <span class="fu">suppressWarnings</span><span class="op">(</span><span class="fu">run.RCTD</span><span class="op">(</span><span class="va">myRCTD</span>, doublet_mode <span class="op">=</span> <span class="st">'full'</span><span class="op">)</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="va">myRCTD</span></span>
<span><span class="op">}</span></span></code></pre>
</div>
</section><section><h2 class="section-heading" id="running-deconvolution-on-brain-samples">Running Deconvolution on Brain Samples<a class="anchor" aria-label="anchor" href="#running-deconvolution-on-brain-samples"></a>
</h2>
<hr class="half-width">
<p>We apply the RCTD wrapper to our spatial transcriptomics data to
deconvolve the spots and quantify the cell types. This may take ~10
minutes. If you prefer, you can load the precomputed results
directly.</p>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Change this variable to TRUE to load precomputed results, or FALSE to </span></span>
<span><span class="co"># compute the results here.</span></span>
<span><span class="va">load.precomputed.results</span> <span class="op">&lt;-</span> <span class="cn">TRUE</span></span>
<span></span>
<span><span class="va">rds.file</span> <span class="op">&lt;-</span> <span class="fu">paste0</span><span class="op">(</span><span class="st">"data/rctd-sample-1.rds"</span><span class="op">)</span></span>
<span></span>
<span><span class="kw">if</span><span class="op">(</span><span class="op">!</span><span class="va">load.precomputed.results</span> <span class="op">||</span> <span class="op">!</span><span class="fu">file.exists</span><span class="op">(</span><span class="va">rds.file</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span></span>
<span>  <span class="va">result_1</span> <span class="op">&lt;-</span> <span class="fu">run.rctd</span><span class="op">(</span><span class="va">sc_reference</span>, <span class="va">sct_st</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co"># The RCTD file is large. To save space, we will remove the reference </span></span>
<span>  <span class="co"># counts. This is necessary owing to constraints on sizes of files </span></span>
<span>  <span class="co"># uploaded to github during the automated build of this site. It will </span></span>
<span>  <span class="co"># not be required for your own analyses.</span></span>
<span>  <span class="co"># We use the remove.RCTD.reference.counts utility function defined in </span></span>
<span>  <span class="co"># code/spatial_utils.R.</span></span>
<span>  <span class="va">result_1</span> <span class="op">&lt;-</span> <span class="fu">remove.RCTD.reference.counts</span><span class="op">(</span><span class="va">result_1</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="fu">saveRDS</span><span class="op">(</span><span class="va">result_1</span>, <span class="va">rds.file</span><span class="op">)</span></span>
<span></span>
<span><span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span></span>
<span>  <span class="va">result_1</span> <span class="op">&lt;-</span> <span class="fu">readRDS</span><span class="op">(</span><span class="va">rds.file</span><span class="op">)</span></span>
<span></span>
<span><span class="op">}</span></span></code></pre>
</div>
</section><section><h2 class="section-heading" id="interpreting-deconvolution-results">Interpreting Deconvolution Results<a class="anchor" aria-label="anchor" href="#interpreting-deconvolution-results"></a>
</h2>
<hr class="half-width">
<p>RCTD outputs the proportion of different cell types in each spatial
spot. These are held in the <code>spatialRNA@counts</code> slot. Let’s
see the proportions it predicts for this sample:</p>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Defining propotion of each cell type per spot. </span></span>
<span><span class="va">props</span> <span class="op">&lt;-</span> <span class="fu">as.data.frame</span><span class="op">(</span><span class="va">result_1</span><span class="op">@</span><span class="va">results</span><span class="op">$</span><span class="va">weights</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Print the first few lines of the deconvolution results</span></span>
<span><span class="co"># Each row is a spot and each column is propotion of each cell type in that spot</span></span>
<span><span class="fu">head</span><span class="op">(</span><span class="va">props</span><span class="op">)</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>                      AST-FB         L2-3           L4         L5-6
AAACAAGTATCTCCCA-1 0.2906892 1.989539e-01 3.568361e-01 9.495123e-04
AAACAATCTACTAGCA-1 0.3665241 4.652610e-04 4.652610e-04 4.601510e-01
AAACACCAATAACTGC-1 0.1069532 5.473749e-05 5.473749e-05 5.473749e-05
AAACAGAGCGACTCCT-1 0.3845201 4.758347e-01 3.256827e-04 3.256827e-04
AAACAGCTTTCAGAAG-1 0.2411203 3.694851e-01 1.995963e-01 6.646586e-04
AAACAGGGTCTATATT-1 0.2096408 3.256827e-04 3.624793e-04 5.117059e-01
                   Oligodendrocytes
AAACAAGTATCTCCCA-1       0.04291383
AAACAATCTACTAGCA-1       0.12784650
AAACACCAATAACTGC-1       1.25940541
AAACAGAGCGACTCCT-1       0.06181266
AAACAGCTTTCAGAAG-1       0.23374357
AAACAGGGTCTATATT-1       0.46602478</code></pre>
</div>
<p>Notice that the proportions don’t sum exactly to one:</p>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Print sum of cell type propotions in each spot</span></span>
<span><span class="fu">head</span><span class="op">(</span><span class="fu">rowSums</span><span class="op">(</span><span class="va">props</span><span class="op">)</span><span class="op">)</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>AAACAAGTATCTCCCA-1 AAACAATCTACTAGCA-1 AAACACCAATAACTGC-1 AAACAGAGCGACTCCT-1
         0.8903426          0.9554521          1.3665228          0.9228188
AAACAGCTTTCAGAAG-1 AAACAGGGTCTATATT-1
         1.0446099          1.1880596 </code></pre>
</div>
<p>Let’s classify each spot according to the layer type with highest
proportion:</p>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Classifying each spot based on the maximum propotion of a cell type in that spot.</span></span>
<span><span class="va">props</span><span class="op">$</span><span class="va">classification</span> <span class="op">&lt;-</span> <span class="fu">colnames</span><span class="op">(</span><span class="va">props</span><span class="op">)</span><span class="op">[</span><span class="fu">apply</span><span class="op">(</span><span class="va">props</span>, <span class="fl">1</span>, <span class="va">which.max</span><span class="op">)</span><span class="op">]</span></span></code></pre>
</div>
<p>Let’s add the deconvolution results to our Seurat object, so that
they can be visualized and analyzed alongside other data organized
there.</p>
<div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Adding cell type propotions to seurat object.</span></span>
<span><span class="va">sct_st</span> <span class="op">&lt;-</span> <span class="fu">AddMetaData</span><span class="op">(</span>object <span class="op">=</span> <span class="va">sct_st</span>, metadata <span class="op">=</span>  <span class="va">props</span><span class="op">)</span></span></code></pre>
</div>
<p>We can now visualize the predicted layer classifications and compare
them alongside the authors’ annotations that we saw previously.</p>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Plot classification of each spot based on RCTD results.</span></span>
<span><span class="fu">SpatialDimPlotColorSafe</span><span class="op">(</span><span class="va">sct_st</span><span class="op">[</span>, <span class="op">!</span><span class="fu">is.na</span><span class="op">(</span><span class="va">sct_st</span><span class="op">[[</span><span class="op">]</span><span class="op">]</span><span class="op">$</span><span class="va">classification</span><span class="op">)</span><span class="op">]</span>, </span>
<span>                        <span class="st">"classification"</span><span class="op">)</span></span></code></pre>
</div>
<figure><img src="fig/deconvolve-cell-types-in-a-spot-rendered-unnamed-chunk-10-1.png" style="display: block; margin: auto;" class="figure mx-auto d-block"></figure><div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Plot classification of each spot based on annotation of a biologist.</span></span>
<span><span class="fu">SpatialDimPlotColorSafe</span><span class="op">(</span><span class="va">sct_st</span><span class="op">[</span>, <span class="op">!</span><span class="fu">is.na</span><span class="op">(</span><span class="va">sct_st</span><span class="op">[[</span><span class="op">]</span><span class="op">]</span><span class="op">$</span><span class="va">layer_guess</span><span class="op">)</span><span class="op">]</span>, </span>
<span>                        <span class="st">"layer_guess"</span><span class="op">)</span></span></code></pre>
</div>
<figure><img src="fig/deconvolve-cell-types-in-a-spot-rendered-unnamed-chunk-11-1.png" style="display: block; margin: auto;" class="figure mx-auto d-block"></figure><p>To be more quantitative, we can compute a confusion matrix comparing
the layers predicted by RCTD with those annotated by the authors.</p>
<div class="codewrapper sourceCode" id="cb13">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Compare predictions from RCTD with annotation done by biologist. </span></span>
<span><span class="va">df</span>            <span class="op">&lt;-</span> <span class="fu">as.data.frame</span><span class="op">(</span><span class="fu">table</span><span class="op">(</span><span class="va">sct_st</span><span class="op">[[</span><span class="op">]</span><span class="op">]</span><span class="op">$</span><span class="va">layer_guess</span>, </span>
<span>                                     <span class="va">sct_st</span><span class="op">[[</span><span class="op">]</span><span class="op">]</span><span class="op">$</span><span class="va">classification</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu">colnames</span><span class="op">(</span><span class="va">df</span><span class="op">)</span>  <span class="op">&lt;-</span> <span class="fu">c</span><span class="op">(</span><span class="st">"Annotation"</span>, <span class="st">"Prediction"</span>, <span class="st">"Freq"</span><span class="op">)</span></span>
<span><span class="va">df</span><span class="op">$</span><span class="va">Annotation</span> <span class="op">&lt;-</span> <span class="fu">factor</span><span class="op">(</span><span class="va">df</span><span class="op">$</span><span class="va">Annotation</span><span class="op">)</span></span>
<span><span class="va">df</span><span class="op">$</span><span class="va">Prediction</span> <span class="op">&lt;-</span> <span class="fu">factor</span><span class="op">(</span><span class="va">df</span><span class="op">$</span><span class="va">Prediction</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">ggplot</span><span class="op">(</span>data <span class="op">=</span> <span class="va">df</span>, <span class="fu">aes</span><span class="op">(</span>x <span class="op">=</span> <span class="va">Annotation</span>, y <span class="op">=</span> <span class="va">Prediction</span>, fill <span class="op">=</span> <span class="va">Freq</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span> </span>
<span>  <span class="fu">geom_tile</span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">theme</span><span class="op">(</span>text <span class="op">=</span> <span class="fu">element_text</span><span class="op">(</span>size <span class="op">=</span> <span class="fl">20</span><span class="op">)</span>, </span>
<span>        axis.text.x <span class="op">=</span> <span class="fu">element_text</span><span class="op">(</span>angle <span class="op">=</span> <span class="fl">45</span>, vjust <span class="op">=</span> <span class="fl">1</span>, hjust<span class="op">=</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span></span></code></pre>
</div>
<figure><img src="fig/deconvolve-cell-types-in-a-spot-rendered-unnamed-chunk-12-1.png" style="display: block; margin: auto;" class="figure mx-auto d-block"></figure><p>Note that there is a fairly strong correlation between the predicted
and observed layers, particularly for the pairs Oligodendrocytes and WM
(White Matter), L4 and Layer 4, and L2-3 and Layer 3.</p>
</section><section><h2 class="section-heading" id="summary">Summary<a class="anchor" aria-label="anchor" href="#summary"></a>
</h2>
<hr class="half-width">
<p>Deconvolution quantifies the cell type composition of each spot.
Doing so enables downstream analyses, such as the proportion of various
cell types across a sample, heterogeneity of cell types across the
sample, or co-localization analyses of cell types within the sample.
Supervised (<em>i.e.</em>, reference-based) and unsupervised approaches
have been developed.</p>
<p>Here, we applied deconvolution supervised by scRNA-seq annotations,
as implemented in RCTD, to a brain sample. The highly structured
organization of the brain allows clear visual confirmation of
deconvolution results. Other tissues may have less structure and more
intermingling of cell types. For example, a typical use of deconvolution
in a cancer setting is to explore co-localization of tumor and immune
cells.</p>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>Deconvolution enhances spatial transcriptomics by quantifying the
different cell types within spatial spots.</li>
<li>Integrating scRNA-seq data with spatial transcriptomics data
facilitates accurate deconvolution.</li>
<li>RCTD is a supervised deconvolution method that quantifies the
proportion of different cell types in spatial transcriptomics data.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-differential-expression-testing"><p>Content from <a href="differential-expression-testing.html">Differential Expression Testing</a></p>
<hr>
<p>Last updated on 2025-03-04 |

        <a href="https://github.com/smcclatchy/spatial-transcriptomics/edit/main/episodes/differential-expression-testing.Rmd" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>How can we assess region-specific gene expression using differential
expression?</li>
<li>How can we assess spatially varying gene expression using spatial
statistics?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Identify differentially expressed genes across different layers
defined by expert annotations.</li>
<li>Utilize the Moran’s I statistic to find spatially variable
genes.</li>
<li>Explore the relationship between layer-specific genes identified by
differential expression and spatially varying genes identified by
Moran’s I.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="spot-level-differential-expression-across-annotated-regions">Spot-level Differential Expression Across Annotated Regions<a class="anchor" aria-label="anchor" href="#spot-level-differential-expression-across-annotated-regions"></a>
</h2>
<hr class="half-width">
<p>We will begin by performing differential expression (DE) across the
annotated layers. We will use the source publication’s spot annotation,
which is stored in the <code>layer_guess</code> column of the metadata.
As a reminder, those look like:</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">SpatialDimPlotColorSafe</span><span class="op">(</span><span class="va">sct_st</span><span class="op">[</span>, <span class="op">!</span><span class="fu">is.na</span><span class="op">(</span><span class="va">sct_st</span><span class="op">[[</span><span class="op">]</span><span class="op">]</span><span class="op">$</span><span class="va">layer_guess</span><span class="op">)</span><span class="op">]</span>, </span>
<span>                        <span class="st">"layer_guess"</span><span class="op">)</span> <span class="op">+</span> </span>
<span>  <span class="fu">labs</span><span class="op">(</span>fill <span class="op">=</span> <span class="st">"Layer"</span><span class="op">)</span> </span></code></pre>
</div>
<figure><img src="fig/differential-expression-testing-rendered-layers-1.png" style="display: block; margin: auto;" class="figure mx-auto d-block"></figure><p>We identify genes that are upregulated in each annotated brain region
using the <a href="https://satijalab.org/seurat/reference/findallmarkers" class="external-link"><code>FindAllMarkers</code></a>
function in Seurat. This performs a “one versus rest” comparison of a
gene’s expression in one region relative to that gene’s expression in
all other regions. The default test used here, the Wilcoxon Rank Sum
test, will use an efficient implementation within the <a href="https://github.com/immunogenomics/presto" class="external-link"><code>presto</code></a>
library, if installed. The speedup over the default implementation is
substantial, and we highly recommend installing <code>presto</code> and
using Seurat v5, which leverages it.</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">Idents</span><span class="op">(</span><span class="va">sct_st</span><span class="op">)</span>  <span class="op">&lt;-</span> <span class="st">"layer_guess"</span></span>
<span><span class="va">de_genes</span>           <span class="op">&lt;-</span> <span class="fu">FindAllMarkers</span><span class="op">(</span><span class="va">sct_st</span>, </span>
<span>                                     assay    <span class="op">=</span> <span class="st">"SCT"</span>,</span>
<span>                                     verbose  <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>                                     only.pos <span class="op">=</span> <span class="cn">TRUE</span>, </span>
<span>                                     min.pct  <span class="op">=</span> <span class="fl">0.25</span>, </span>
<span>                                     logfc.threshold <span class="op">=</span> <span class="fl">0.25</span><span class="op">)</span></span></code></pre>
</div>
<p>The resulting table indicates DE p-values and adjusted p-values for
each gene, along with the percentage of spots in which the gene was
detected (pct.1) in the corresponding cluster and the percentage of
spots in which it was detected in all <em>other</em> clusters
(pct.2):</p>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">head</span><span class="op">(</span><span class="va">de_genes</span><span class="op">)</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>                p_val avg_log2FC pct.1 pct.2     p_val_adj cluster    gene
MT-CO1  7.490920e-163  0.3732349 1.000  1.00 1.348066e-158  Layer3  MT-CO1
ENC1    1.306480e-142  0.8693104 0.998  0.93 2.351142e-138  Layer3    ENC1
MT-ATP6 7.395810e-127  0.3333148 1.000  1.00 1.330950e-122  Layer3 MT-ATP6
MT-CYB  1.306736e-117  0.3288096 1.000  1.00 2.351602e-113  Layer3  MT-CYB
MT-CO2  3.611734e-116  0.2869348 1.000  1.00 6.499677e-112  Layer3  MT-CO2
MT-CO3  6.536277e-105  0.2765344 1.000  1.00 1.176268e-100  Layer3  MT-CO3</code></pre>
</div>
<p>It is not uncommon to have pathologist annotations of regions. The
Visium assay is performed on a tissue that is also stained for
hematoxylin and eosin (H&amp;E) – a routine practice in pathology for
diagnosing cancer, for example. A pathologist could manually annotate
this H&amp;E image using a histology viewer, such as QuPath.</p>
</section><section><h2 class="section-heading" id="spot-level-differential-expression-across-clusters">Spot-level Differential Expression Across Clusters<a class="anchor" aria-label="anchor" href="#spot-level-differential-expression-across-clusters"></a>
</h2>
<hr class="half-width">
<p>In cases where we do not have expert annotations, we could perform
the analysis above across clusters. Indeed, this is often the first step
to interpreting a cluster – comparing its marker genes to those of
regions expected within the tissue. It is important to remember,
however, that these markers are for clusters of spots – aggregations of
cells – not individual cells, as would be the case in scRNA-seq. Those
aggregations may be of cells with similar types, in which case analysis
may be similar to that of scRNA-seq, or of different cell types, in
which case the interpretation would be quite different than with
scRNA-seq. Let’s try this.</p>
<p>First, let’s remind ourselves what the clusters look like:</p>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">SpatialDimPlotColorSafe</span><span class="op">(</span><span class="va">sct_st</span>, <span class="st">"seurat_clusters"</span><span class="op">)</span> <span class="op">+</span> </span>
<span>  <span class="fu">labs</span><span class="op">(</span>fill <span class="op">=</span> <span class="st">"Cluster"</span><span class="op">)</span> </span></code></pre>
</div>
<figure><img src="fig/differential-expression-testing-rendered-clusters-1.png" style="display: block; margin: auto;" class="figure mx-auto d-block"></figure><p>Now, we will use nearly identical code as above to perform the
differential expression analysis. We only change each cell’s identity
class with the <a href="https://satijalab.github.io/seurat-object/reference/Idents.html" class="external-link"><code>Idents</code></a>
function, to associate each cell with its cluster.</p>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">Idents</span><span class="op">(</span><span class="va">sct_st</span><span class="op">)</span>  <span class="op">&lt;-</span> <span class="st">"seurat_clusters"</span></span>
<span><span class="va">de_genes_cluster</span>   <span class="op">&lt;-</span> <span class="fu">FindAllMarkers</span><span class="op">(</span><span class="va">sct_st</span>, </span>
<span>                                     assay    <span class="op">=</span> <span class="st">"SCT"</span>,</span>
<span>                                     verbose  <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>                                     only.pos <span class="op">=</span> <span class="cn">TRUE</span>, </span>
<span>                                     min.pct  <span class="op">=</span> <span class="fl">0.25</span>, </span>
<span>                                     logfc.threshold <span class="op">=</span> <span class="fl">0.25</span><span class="op">)</span></span></code></pre>
</div>
<p>Let’s visualize the overlap between genes differentially expressed
across annotated layers and those differentially expressed across
clusters. We will do so using a confusion matrix.</p>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">de_genes_all</span> <span class="op">&lt;-</span> <span class="fu">merge</span><span class="op">(</span><span class="fu">subset</span><span class="op">(</span><span class="va">de_genes</span>, <span class="va">p_val_adj</span> <span class="op">&lt;</span> <span class="fl">0.05</span><span class="op">)</span>,</span>
<span>                      <span class="fu">subset</span><span class="op">(</span><span class="va">de_genes_cluster</span>, <span class="va">p_val_adj</span> <span class="op">&lt;</span> <span class="fl">0.05</span><span class="op">)</span>,</span>
<span>                      by<span class="op">=</span><span class="fu">c</span><span class="op">(</span><span class="st">"gene"</span><span class="op">)</span>, all<span class="op">=</span><span class="cn">TRUE</span>, </span>
<span>                      suffixes <span class="op">=</span> <span class="fu">c</span><span class="op">(</span><span class="st">".anno"</span>, <span class="st">".cluster"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">layer.order</span> <span class="op">&lt;-</span> <span class="fu">c</span><span class="op">(</span><span class="st">"WM"</span>, <span class="st">"Layer1"</span>, <span class="st">"Layer2"</span>, <span class="st">"Layer3"</span>, <span class="st">"Layer4"</span>, </span>
<span>                 <span class="st">"Layer5"</span>, <span class="st">"Layer6"</span><span class="op">)</span></span>
<span><span class="va">df</span>            <span class="op">&lt;-</span> <span class="fu">as.data.frame</span><span class="op">(</span><span class="fu">table</span><span class="op">(</span><span class="va">de_genes_all</span><span class="op">$</span><span class="va">cluster.anno</span>, </span>
<span>                                     <span class="va">de_genes_all</span><span class="op">$</span><span class="va">cluster.cluster</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu">colnames</span><span class="op">(</span><span class="va">df</span><span class="op">)</span>  <span class="op">&lt;-</span> <span class="fu">c</span><span class="op">(</span><span class="st">"de.anno"</span>, <span class="st">"de.cluster"</span>, <span class="st">"Freq"</span><span class="op">)</span></span>
<span><span class="va">df</span><span class="op">$</span><span class="va">de.anno</span> <span class="op">&lt;-</span> <span class="fu">factor</span><span class="op">(</span><span class="va">df</span><span class="op">$</span><span class="va">de.anno</span>, levels <span class="op">=</span> <span class="fu">c</span><span class="op">(</span><span class="st">"NA"</span>, <span class="va">layer.order</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">df</span><span class="op">$</span><span class="va">de.cluster</span> <span class="op">&lt;-</span> <span class="fu">factor</span><span class="op">(</span><span class="va">df</span><span class="op">$</span><span class="va">de.cluster</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">ggplot</span><span class="op">(</span>data <span class="op">=</span> <span class="va">df</span>, <span class="fu">aes</span><span class="op">(</span>x <span class="op">=</span> <span class="va">de.anno</span>, y <span class="op">=</span> <span class="va">de.cluster</span>, fill <span class="op">=</span> <span class="va">Freq</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">geom_tile</span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">theme</span><span class="op">(</span>text <span class="op">=</span> <span class="fu">element_text</span><span class="op">(</span>size <span class="op">=</span> <span class="fl">20</span><span class="op">)</span>, </span>
<span>        axis.text.x <span class="op">=</span> <span class="fu">element_text</span><span class="op">(</span>angle <span class="op">=</span> <span class="fl">45</span>, vjust <span class="op">=</span> <span class="fl">1</span>, hjust<span class="op">=</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">xlab</span><span class="op">(</span><span class="st">"Annotation-based DE Genes"</span><span class="op">)</span> <span class="op">+</span> <span class="fu">ylab</span><span class="op">(</span><span class="st">"Cluster-based DE Genes"</span><span class="op">)</span></span></code></pre>
</div>
<figure><img src="fig/differential-expression-testing-rendered-de-comparison-confusion-1.png" style="display: block; margin: auto;" class="figure mx-auto d-block"></figure><p>The above plot shows only marginal overlap between the
annotation-derived DE genes on the x axis and the cluster-derived DE
genes on the y axis. This might indicate that the two approaches are
complementary. In fact, they could be used in conjunction. We could have
performed clustering <em>within</em> the annotated regions to assess
intra-layer heterogeneity.</p>
</section><section><h2 class="section-heading" id="morans-i-statistic">Moran’s I Statistic<a class="anchor" aria-label="anchor" href="#morans-i-statistic"></a>
</h2>
<hr class="half-width">
<p>We next consider an alternative to the above approaches that both
rely on defined regions – be they defined from expert annotation or via
clustering. Instead, we will apply the Moran’s I statistic. Moran’s I is
a measure used to assess spatial autocorrelation in data, indicating
whether similar values of a feature (<em>e.g.</em>, expression levels of
a gene) are clustered, dispersed, or random (<a href="https://ij-healthgeographics.biomedcentral.com/articles/10.1186/1476-072X-9-33" class="external-link">Jackson,
et al. 2010</a>). These correspond to Moran’s I values that are
positive, negative, or near zero, respectively.</p>
<figure><img src="https://upload.wikimedia.org/wikipedia/commons/f/f0/Moran%27s_I_example.png" alt="Moran's I statistic quantifies spatial correlation." class="figure mx-auto d-block"><div class="figcaption">Moran’s I statistic quantifies spatial
correlation. <strong>Top Left:</strong> Checkerboard pattern results in
negative Moran’s I, indicating anti-correlation. <strong>Top
Right:</strong> Linear gradient shows a high positive Moran’s I,
reflecting a strong spatial gradient. <strong>Bottom Left:</strong>
Random pattern leads to a Moran’s I near zero, suggesting no significant
spatial autocorrelation. <strong>Bottom Right:</strong> ‘Ink blot’
pattern demonstrates positive autocorrelation, indicative of a clustered
or spreading pattern. Relationships are calculated using direct, equally
weighted neighbors, normalized for each cell.</div>
</figure><p>Image by
<a href="https://commons.wikimedia.org/wiki/File:Moran%27s_I_example.png" class="external-link">WikiNukalito</a>,
<a href="https://creativecommons.org/licenses/by-sa/4.0" class="external-link">CC BY-SA
4.0</a>, via Wikimedia Commons.</p>
<p>Here, we can apply it to detect genes whose expression patterns
exhibit spatial structure, which may reflect region-specific, biological
function. That is, we anticipate that spatially variable genes will
exhibit region-specific expression. Let’s check that hypothesis by first
computing spatially variable genes and then assessing whether they are
differentially expressed across regions.</p>
<div class="section level3">
<h3 id="spatial-differential-expression-using-morans-i">Spatial Differential Expression Using Moran’s I<a class="anchor" aria-label="anchor" href="#spatial-differential-expression-using-morans-i"></a>
</h3>
<p>We identify the genes whose expression patterns exhibit clear spatial
structure using Moran’s I algorithm, as implemented in <a href="https://satijalab.org/seurat/reference/findspatiallyvariablefeatures" class="external-link"><code>FindSpatiallyVariableFeatures</code></a>.
We have selected the top 1,000 genes, which should be sufficient to
identify brain regions. The following will take several minutes to
run.</p>
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">svg</span> <span class="op">&lt;-</span> </span>
<span>  <span class="fu">FindSpatiallyVariableFeatures</span><span class="op">(</span><span class="va">sct_st</span>, </span>
<span>                                assay            <span class="op">=</span> <span class="st">"SCT"</span>, </span>
<span>                                features         <span class="op">=</span> <span class="fu">VariableFeatures</span><span class="op">(</span><span class="va">sct_st</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">1000</span><span class="op">]</span>, </span>
<span>                                selection.method <span class="op">=</span> <span class="st">"moransi"</span><span class="op">)</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">ERROR<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="error" tabindex="0"><code>Error: 'RunMoransI' requires either Rfast2 or ape to be installed</code></pre>
</div>
<p><code>FindSpatiallyVariableFeatures</code> returns a Seurat object,
populated with Moran’s I-derived results. Normally, we would use the <a href="https://satijalab.github.io/seurat-object/reference/VariableFeatures.html" class="external-link"><code>SpatiallyVariableFeatures</code></a>
function to query those results. But, there is a bug in that function as
described <a href="https://github.com/satijalab/seurat/issues/7422" class="external-link">in
Seurat’s issue pages</a>. So, instead we will manually extract the top
100 ranked spatially variable genes, along with their Moran’s I values
and associated p-values:</p>
<div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Get and sort 'MoransI_observed' values</span></span>
<span><span class="va">morans_i_genes</span> <span class="op">&lt;-</span> <span class="va">svg</span><span class="op">@</span><span class="va">assays</span><span class="op">[[</span><span class="st">"SCT"</span><span class="op">]</span><span class="op">]</span><span class="op">@</span><span class="va">meta.features</span> <span class="op">%&gt;%</span></span>
<span>                    <span class="fu">rownames_to_column</span><span class="op">(</span><span class="st">"gene"</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>                    <span class="fu">arrange</span><span class="op">(</span><span class="fu">desc</span><span class="op">(</span><span class="va">MoransI_observed</span><span class="op">)</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>                    <span class="fu">slice_head</span><span class="op">(</span>n <span class="op">=</span> <span class="fl">100</span><span class="op">)</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">ERROR<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="error" tabindex="0"><code>Error in svg@assays: no applicable method for `@` applied to an object of class "function"</code></pre>
</div>
<div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">head</span><span class="op">(</span><span class="va">morans_i_genes</span><span class="op">)</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">ERROR<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="error" tabindex="0"><code>Error in h(simpleError(msg, call)): error in evaluating the argument 'x' in selecting a method for function 'head': object 'morans_i_genes' not found</code></pre>
</div>
</div>
</section><section><h2 class="section-heading" id="correlation-of-region-specific-differentially-expressed-genes-and-spatially-variable-genes">Correlation of Region-specific Differentially Expressed Genes and
Spatially Variable Genes<a class="anchor" aria-label="anchor" href="#correlation-of-region-specific-differentially-expressed-genes-and-spatially-variable-genes"></a>
</h2>
<hr class="half-width">
<div class="section level3">
<h3 id="heatmap-of-differential-expression">Heatmap of Differential Expression<a class="anchor" aria-label="anchor" href="#heatmap-of-differential-expression"></a>
</h3>
<p>As a sanity check of both the region-specific differential expression
and the Moran’s I approaches, let’s check our hypothesis that spatially
variable genes are likely to show regional differential expression. To
do this, we will plot a heatmap of the <em>differential expression</em>
p-values for the top 100 spatially variable genes, organized by brain
region.</p>
<div class="codewrapper sourceCode" id="cb14">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Merge the Moran's I values with the DE genes</span></span>
<span><span class="va">df</span> <span class="op">&lt;-</span> <span class="fu">merge</span><span class="op">(</span><span class="va">morans_i_genes</span>, <span class="va">de_genes</span>, all.x <span class="op">=</span> <span class="cn">TRUE</span>, by <span class="op">=</span> <span class="st">"gene"</span><span class="op">)</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">ERROR<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="error" tabindex="0"><code>Error in h(simpleError(msg, call)): error in evaluating the argument 'x' in selecting a method for function 'merge': object 'morans_i_genes' not found</code></pre>
</div>
<div class="codewrapper sourceCode" id="cb16">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">df</span> <span class="op">&lt;-</span> <span class="fu">subset</span><span class="op">(</span><span class="va">df</span>, <span class="op">!</span><span class="fu">is.na</span><span class="op">(</span><span class="va">cluster</span><span class="op">)</span><span class="op">)</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">ERROR<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="error" tabindex="0"><code>Error in eval(e, x, parent.frame()): object 'cluster' not found</code></pre>
</div>
<div class="codewrapper sourceCode" id="cb18">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># We will plot the -log2 pvalues. Compute this and adjust for taking </span></span>
<span><span class="co"># log of 0.</span></span>
<span><span class="va">df</span><span class="op">$</span><span class="va">log_p_val_adj</span> <span class="op">&lt;-</span> <span class="op">-</span><span class="fu">log2</span><span class="op">(</span><span class="va">df</span><span class="op">$</span><span class="va">p_val_adj</span><span class="op">)</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">ERROR<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="error" tabindex="0"><code>Error in log2(df$p_val_adj): non-numeric argument to mathematical function</code></pre>
</div>
<div class="codewrapper sourceCode" id="cb20">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">df</span><span class="op">$</span><span class="va">log_p_val_adj</span><span class="op">[</span><span class="fu">is.infinite</span><span class="op">(</span><span class="va">df</span><span class="op">$</span><span class="va">log_p_val_adj</span><span class="op">)</span><span class="op">]</span> <span class="op">&lt;-</span> </span>
<span>  <span class="fu">max</span><span class="op">(</span><span class="va">df</span><span class="op">$</span><span class="va">log_p_val_adj</span><span class="op">[</span><span class="op">!</span><span class="fu">is.infinite</span><span class="op">(</span><span class="va">df</span><span class="op">$</span><span class="va">log_p_val_adj</span><span class="op">)</span><span class="op">]</span><span class="op">)</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">WARNING<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="warning" tabindex="0"><code>Warning in max(df$log_p_val_adj[!is.infinite(df$log_p_val_adj)]): no
non-missing arguments to max; returning -Inf</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">ERROR<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="error" tabindex="0"><code>Error in `$&lt;-.data.frame`(`*tmp*`, log_p_val_adj, value = numeric(0)): replacement has 0 rows, data has 56</code></pre>
</div>
<div class="codewrapper sourceCode" id="cb23">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Create a matrix whose rows are the spatially variable genes </span></span>
<span><span class="co"># (indicated by Moran's I), whose columns are the clusters, and whose </span></span>
<span><span class="co"># entries are the adjusted DE pvalue for the corresponding gene and cluster.</span></span>
<span><span class="va">p_val_adj_matrix</span> <span class="op">&lt;-</span> <span class="va">df</span> <span class="op">%&gt;%</span></span>
<span>                       <span class="fu">select</span><span class="op">(</span><span class="va">gene</span>, <span class="va">cluster</span>,<span class="va">log_p_val_adj</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>                       <span class="fu">pivot_wider</span><span class="op">(</span>names_from <span class="op">=</span> <span class="va">cluster</span>, </span>
<span>                                   values_from <span class="op">=</span> <span class="va">log_p_val_adj</span>, </span>
<span>                                   values_fill <span class="op">=</span> <span class="fl">0</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>                       <span class="fu">column_to_rownames</span><span class="op">(</span><span class="st">"gene"</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>                       <span class="fu">as.matrix</span><span class="op">(</span><span class="op">)</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">ERROR<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="error" tabindex="0"><code>Error in (function (cond) : error in evaluating the argument 'x' in selecting a method for function 'as.matrix': Can't select columns that don't exist.
✖ Column `gene` doesn't exist.</code></pre>
</div>
<div class="codewrapper sourceCode" id="cb25">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Order the regions according to their spatial organization from </span></span>
<span><span class="co"># inner to outer layers</span></span>
<span><span class="va">p_val_adj_matrix</span> <span class="op">&lt;-</span> <span class="va">p_val_adj_matrix</span><span class="op">[</span>, <span class="va">layer.order</span><span class="op">]</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">ERROR<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="error" tabindex="0"><code>Error: object 'p_val_adj_matrix' not found</code></pre>
</div>
<div class="codewrapper sourceCode" id="cb27">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Create a heatmap of the DE p-values of spatially variable genes</span></span>
<span><span class="fu">Heatmap</span><span class="op">(</span><span class="va">p_val_adj_matrix</span>,</span>
<span>        column_title      <span class="op">=</span> <span class="st">"Heatmap of DE p-values of spatially variable genes"</span>,</span>
<span>        name              <span class="op">=</span> <span class="st">"DE -log2(p-values)"</span>, <span class="co"># Title for the heatmap legend</span></span>
<span>        row_title         <span class="op">=</span> <span class="st">"Spatially variable genes"</span>,</span>
<span>        cluster_rows      <span class="op">=</span> <span class="cn">TRUE</span>, </span>
<span>        cluster_columns   <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>        show_row_names    <span class="op">=</span> <span class="cn">FALSE</span>, </span>
<span>        show_column_names <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>        show_row_dend     <span class="op">=</span> <span class="cn">FALSE</span>, </span>
<span>        show_column_dend  <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">ERROR<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="error" tabindex="0"><code>Error: object 'p_val_adj_matrix' not found</code></pre>
</div>
<p>The heatmap visualization reveals a key finding of our analysis:
genes displaying the highest Moran’s I values show distinct expression
patterns that align with specific brain regions identified through
expert annotations. This observation underscores the spatial correlation
of gene expression, highlighting its potential relevance in
understanding regional brain functions and pathologies.</p>
</div>
</section><section><h2 class="section-heading" id="differential-expression-analysis-for-multiple-samples">Differential Expression Analysis for Multiple Samples<a class="anchor" aria-label="anchor" href="#differential-expression-analysis-for-multiple-samples"></a>
</h2>
<hr class="half-width">
<p>Till now we have explored spot-level analysis within one sample.
However, most studies (including the published one that furnished the
data we used here) include multiple samples. This has some similarities
to single cell-level DE analysis in scRNA-seq. In the scRNA-seq setting,
several studies, including one by <a href="https://www.nature.com/articles/s41467-021-25960-2" class="external-link">Squair, et
al.</a>, have emphasized drawbacks of performing DE on individual cells.
Single-cell DE may be caused by technical variability across single
cells, biological variability that may not be of interest across
conditions studied (<em>e.g.</em>, transcriptional bursting), or simply
by the large number of individual cells that inflate false positives.
One solution is to perform <em>pseudobulking</em> of the scRNA-seq and
then to use conventional bulk RNA-seq DE tools (<em>e.g.</em>, DESeq2)
to compare the pseudobulks. A Seurat <a href="https://satijalab.org/seurat/articles/de_vignette" class="external-link">vignette</a>
describing the approach for scRNA-seq should likewise be applicable for
spatial transcriptomics. However, we note the caveat that spots are not
cells – the former may have considerably more intra- and inter-spot
biological heterogeneity. Hence, pseudobulking should be done with
caution.</p>
<p>We selected one sample from each subject (<code>151508</code>,
<code>151669</code>, and <code>151673</code>), as detailed in the
referenced study (<a href="https://doi.org/10.1038/s41593-020-00787-0" class="external-link">Maynard et al, Nat
Neurosci 24, 425–436 (2021)</a>). This selection allows us to analyze
the consistency of differential expression across individuals while
accounting for subject-specific batch effects. We start by loading our
samples:</p>
<div class="codewrapper sourceCode" id="cb29">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Define the list of selected sample IDs</span></span>
<span><span class="va">selected_samples</span> <span class="op">&lt;-</span> <span class="fu">c</span><span class="op">(</span><span class="st">"151508"</span>, <span class="st">"151669"</span>,<span class="st">"151673"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Initialize an empty list to store Seurat objects</span></span>
<span><span class="va">st_objects</span> <span class="op">&lt;-</span> <span class="fu">list</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Loop over each sample ID to process the corresponding data</span></span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">sample_id</span> <span class="kw">in</span> <span class="va">selected_samples</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="co"># Construct the directory and filename for data loading</span></span>
<span>  <span class="va">data_dir</span> <span class="op">&lt;-</span> <span class="fu">paste0</span><span class="op">(</span><span class="st">"./data/"</span>, <span class="va">sample_id</span><span class="op">)</span></span>
<span>  <span class="va">filename</span> <span class="op">&lt;-</span> <span class="fu">paste0</span><span class="op">(</span><span class="va">sample_id</span>, <span class="st">"_filtered_feature_bc_matrix.h5"</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co"># Load the spatial transcriptomics data for the current sample</span></span>
<span>  <span class="va">st_obj</span> <span class="op">&lt;-</span> <span class="fu">Load10X_Spatial</span><span class="op">(</span>data.dir <span class="op">=</span> <span class="va">data_dir</span>, filename <span class="op">=</span> <span class="va">filename</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co"># Read in the tissue spot positions from the CSV file</span></span>
<span>  <span class="va">tissue_positions_file</span> <span class="op">&lt;-</span> <span class="fu">paste0</span><span class="op">(</span><span class="va">data_dir</span>, <span class="st">"/spatial/tissue_positions_list.csv"</span><span class="op">)</span></span>
<span>  <span class="va">tissue_position</span> <span class="op">&lt;-</span> <span class="fu">read_csv</span><span class="op">(</span><span class="va">tissue_positions_file</span>, </span>
<span>                              col_names <span class="op">=</span> <span class="cn">FALSE</span>, show_col_types <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>                     <span class="fu">column_to_rownames</span><span class="op">(</span><span class="st">'X1'</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co"># Define column names for the tissue position data</span></span>
<span>  <span class="fu">colnames</span><span class="op">(</span><span class="va">tissue_position</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu">c</span><span class="op">(</span><span class="st">"in_tissue"</span>, <span class="st">"array_row"</span>, <span class="st">"array_col"</span>, </span>
<span>                                 <span class="st">"pxl_row_in_fullres"</span>, <span class="st">"pxl_col_in_fullres"</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co"># Align spot barcodes between the Seurat object and the tissue position metadata</span></span>
<span>  <span class="va">tissue_position</span> <span class="op">&lt;-</span> <span class="va">tissue_position</span><span class="op">[</span><span class="fu">Cells</span><span class="op">(</span><span class="va">st_obj</span><span class="op">)</span>,<span class="op">]</span></span>
<span>  <span class="fu">stopifnot</span><span class="op">(</span><span class="fu">rownames</span><span class="op">(</span><span class="va">tissue_position</span><span class="op">)</span> <span class="op">==</span> <span class="fu">Cells</span><span class="op">(</span><span class="va">st_obj</span><span class="op">)</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co"># Add the aligned tissue position metadata to the Seurat object</span></span>
<span>  <span class="va">st_obj</span> <span class="op">&lt;-</span> <span class="fu">AddMetaData</span><span class="op">(</span>object <span class="op">=</span> <span class="va">st_obj</span>, metadata <span class="op">=</span> <span class="va">tissue_position</span><span class="op">)</span></span>
<span></span>
<span>  <span class="co"># Additionally we add the "layer_guess" and "cell-count" metadata </span></span>
<span>  <span class="va">spot_metadata</span> <span class="op">&lt;-</span> <span class="fu">read.table</span><span class="op">(</span><span class="st">"./data/spot-meta.tsv"</span>, sep<span class="op">=</span><span class="st">"\t"</span><span class="op">)</span></span>
<span>  <span class="co"># Subset to our sample</span></span>
<span>  <span class="va">spot_metadata</span> <span class="op">&lt;-</span> <span class="fu">subset</span><span class="op">(</span><span class="va">spot_metadata</span>, <span class="va">sample_name</span> <span class="op">==</span> <span class="va">sample_id</span><span class="op">)</span></span>
<span>  <span class="fu">rownames</span><span class="op">(</span><span class="va">spot_metadata</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="va">spot_metadata</span><span class="op">$</span><span class="va">barcode</span></span>
<span>  <span class="fu">stopifnot</span><span class="op">(</span><span class="fu">all</span><span class="op">(</span><span class="fu">Cells</span><span class="op">(</span><span class="va">st_obj</span><span class="op">)</span> <span class="op">%in%</span> <span class="fu">rownames</span><span class="op">(</span><span class="va">spot_metadata</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="va">spot_metadata</span> <span class="op">&lt;-</span> <span class="va">spot_metadata</span><span class="op">[</span><span class="fu">Cells</span><span class="op">(</span><span class="va">st_obj</span><span class="op">)</span>,<span class="op">]</span></span>
<span>  </span>
<span>  <span class="va">st_obj</span> <span class="op">&lt;-</span> <span class="fu">AddMetaData</span><span class="op">(</span>object <span class="op">=</span> <span class="va">st_obj</span>,</span>
<span>                           metadata <span class="op">=</span> <span class="va">spot_metadata</span><span class="op">[</span>, <span class="fu">c</span><span class="op">(</span><span class="st">"layer_guess"</span>, <span class="st">"cell_count"</span><span class="op">)</span>, drop<span class="op">=</span><span class="cn">FALSE</span><span class="op">]</span><span class="op">)</span></span>
<span></span>
<span>  <span class="co"># Store the updated Seurat object in the list, using the sample ID as the key</span></span>
<span>  <span class="va">st_objects</span><span class="op">[[</span><span class="va">sample_id</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">st_obj</span></span>
<span><span class="op">}</span></span></code></pre>
</div>
<p>Now, st_objects variable contains all the Seurat objects for each
selected sample, indexed by their respective sample IDs.</p>
<div class="section level3">
<h3 id="batch-correction-analysis">Batch correction Analysis<a class="anchor" aria-label="anchor" href="#batch-correction-analysis"></a>
</h3>
<p>When working with multiple samples, batch effects can introduce
technical variability that may confound biological signals. Batch
correction methods can help mitigate these effects. In this section, we
perform pseudobulk analysis and apply PCA to visualize any potential
batch effects across layers.</p>
<div class="codewrapper sourceCode" id="cb30">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Initialize an empty list to store pseudobulked Seurat objects</span></span>
<span><span class="va">pseudobulked_objs</span> <span class="op">&lt;-</span> <span class="fu">list</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Pseudobulk each selected sample by aggregating expression within annotated layers</span></span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="va">selected_samples</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">pseudobulk_seurat</span> <span class="op">&lt;-</span> <span class="fu">AggregateExpression</span><span class="op">(</span><span class="va">st_objects</span><span class="op">[[</span><span class="va">i</span><span class="op">]</span><span class="op">]</span>, </span>
<span>                                           assays <span class="op">=</span> <span class="st">'Spatial'</span>, </span>
<span>                                           return.seurat <span class="op">=</span> <span class="cn">TRUE</span>, </span>
<span>                                           group.by <span class="op">=</span> <span class="st">'layer_guess'</span><span class="op">)</span></span>
<span>  <span class="va">pseudobulk_seurat</span><span class="op">@</span><span class="va">meta.data</span><span class="op">$</span><span class="va">sample</span> <span class="op">&lt;-</span> <span class="fu">names</span><span class="op">(</span><span class="va">st_objects</span><span class="op">[</span><span class="va">i</span><span class="op">]</span><span class="op">)</span></span>
<span>  <span class="va">pseudobulk_seurat</span><span class="op">@</span><span class="va">meta.data</span><span class="op">$</span><span class="va">layer</span> <span class="op">&lt;-</span> <span class="fu">colnames</span><span class="op">(</span><span class="va">pseudobulk_seurat</span><span class="op">@</span><span class="va">assays</span><span class="op">[[</span><span class="st">"Spatial"</span><span class="op">]</span><span class="op">]</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co"># Store the pseudobulked Seurat object in the list</span></span>
<span>  <span class="va">pseudobulked_objs</span><span class="op">[[</span><span class="va">i</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">pseudobulk_seurat</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co"># Merge all pseudobulked Seurat objects into a single Seurat object</span></span>
<span><span class="va">merged_pseudobulk</span> <span class="op">&lt;-</span> <span class="fu">Reduce</span><span class="op">(</span><span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span><span class="op">)</span> <span class="fu">merge</span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span><span class="op">)</span>, <span class="va">pseudobulked_objs</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Normalize, find variable features, and scale the data</span></span>
<span><span class="va">merged_pseudobulk</span> <span class="op">&lt;-</span> <span class="fu">NormalizeData</span><span class="op">(</span><span class="va">merged_pseudobulk</span>, normalization.method <span class="op">=</span> <span class="st">"LogNormalize"</span>, scale.factor <span class="op">=</span> <span class="fl">1e6</span><span class="op">)</span></span>
<span><span class="va">merged_pseudobulk</span> <span class="op">&lt;-</span> <span class="fu">FindVariableFeatures</span><span class="op">(</span><span class="va">merged_pseudobulk</span><span class="op">)</span></span>
<span><span class="va">merged_pseudobulk</span> <span class="op">&lt;-</span> <span class="fu">ScaleData</span><span class="op">(</span><span class="va">merged_pseudobulk</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Run PCA on the merged pseudobulked data</span></span>
<span><span class="va">merged_pseudobulk</span> <span class="op">&lt;-</span> <span class="fu">RunPCA</span><span class="op">(</span><span class="va">merged_pseudobulk</span>, features <span class="op">=</span> <span class="fu">VariableFeatures</span><span class="op">(</span>object <span class="op">=</span> <span class="va">merged_pseudobulk</span><span class="op">)</span>, npcs <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre>
</div>
<p>To assess the presence of batch effects, we visualize the PCA
results. Ideally, the samples should cluster by layer rather than by
sample, indicating that batch effects are not a significant concern.</p>
<div class="codewrapper sourceCode" id="cb31">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Visualize PCA grouped by layer with increased point size and different shapes</span></span>
<span><span class="va">PCAPlot_layer_symbol</span> <span class="op">&lt;-</span> <span class="fu">DimPlot</span><span class="op">(</span><span class="va">merged_pseudobulk</span>, reduction <span class="op">=</span> <span class="st">"pca"</span>, shape.by <span class="op">=</span> <span class="st">"sample"</span>, pt.size <span class="op">=</span> <span class="fl">3</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">theme</span><span class="op">(</span>legend.position <span class="op">=</span> <span class="st">"right"</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">ggtitle</span><span class="op">(</span><span class="st">"PCA Plot Annotated by Layer (Shapes)"</span><span class="op">)</span></span>
<span><span class="va">PCAPlot_layer_symbol</span></span></code></pre>
</div>
<p><img src="fig/differential-expression-testing-rendered-pca_results-1.png" style="display: block; margin: auto;" class="figure"><img src="fig/de_pca.png" alt="" class="figure"></p>
<p>The PCA plot indeed shows that the dots are clustered by layer rather
than by sample, validating that the layers are the primary source of
variation, rather than differences between samples from different
subjects.</p>
<p>If the dots were instead clustered by sample rather than by layer, it
would indicate the presence of batch effects. In bulk or single-cell
RNA-seq studies, batch effects would typically be mitigated by applying
regression-based tools such as <a href="https://portals.broadinstitute.org/harmony/articles/quickstart.html" class="external-link"><code>Harmony</code></a>
or by incorporating a batch factor in a linear modeling framework
(<em>e.g.</em>, of DESeq2). Those approaches could be applied to spatial
transcriptomics data, as well.</p>
</div>
<div class="section level3">
<h3 id="pseudobulk-analysis-with-deseq2">Pseudobulk Analysis with DESeq2<a class="anchor" aria-label="anchor" href="#pseudobulk-analysis-with-deseq2"></a>
</h3>
<p>Pseudobulk analysis allows for the aggregation of single-cell or
spot-level data into larger groups, which can reduce noise and enhance
the detection of biologically meaningful signals. In this section, we
perform differential expression analysis using DESeq2 on pseudobulked
data. DESeq2 is a tool for differential expression analysis,
particularly well-suited for count data, which is the type of data we
have after aggregating the spatial transcriptomics spots into
pseudobulks. It employs a statistical model that accounts for
variability in read counts while controlling for factors such as sample
size and sequencing depth. This makes it particularly powerful in
situations where we expect relatively small changes in gene expression
but need to ensure robustness against noise, making it an ideal choice
for our pseudobulk analysis.</p>
<p>In this case, we compare White Matter (aggregated expression from
spots labeled as White Matter) versus the rest of the tissue (aggregated
expression from spots belonging to all other cotrical layers). This
binary comparison is straightforward yet powerful, as the White Matter
in the brain is distinct from the cortical layers in terms of both
structure and function. By comparing the gene expression in White Matter
to that in all other layers, we aim to identify genes that are uniquely
or predominantly expressed in White Matter and associated with its
functions or pathologies</p>
<div class="codewrapper sourceCode" id="cb32">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">all_columns</span> <span class="op">&lt;-</span> <span class="fu">list</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Function to process each sample and create a new matrix with WM vs. others</span></span>
<span><span class="va">process_sample</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">sample_name</span>, <span class="va">pseudobulked_objs</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">counts_matrix</span> <span class="op">&lt;-</span> <span class="va">pseudobulked_objs</span><span class="op">[[</span><span class="va">sample_name</span><span class="op">]</span><span class="op">]</span><span class="op">@</span><span class="va">assays</span><span class="op">[[</span><span class="st">"Spatial"</span><span class="op">]</span><span class="op">]</span><span class="op">@</span><span class="va">layers</span><span class="op">[[</span><span class="st">"counts"</span><span class="op">]</span><span class="op">]</span></span>
<span>  <span class="va">counts_matrix</span> <span class="op">&lt;-</span> <span class="fu">as</span><span class="op">(</span><span class="va">counts_matrix</span>, <span class="st">"dgCMatrix"</span><span class="op">)</span></span>
<span>  <span class="va">layer_info</span> <span class="op">&lt;-</span> <span class="va">pseudobulked_objs</span><span class="op">[[</span><span class="va">sample_name</span><span class="op">]</span><span class="op">]</span><span class="op">@</span><span class="va">meta.data</span><span class="op">[[</span><span class="st">"layer_guess"</span><span class="op">]</span><span class="op">]</span></span>
<span>  <span class="va">white_matter_col</span> <span class="op">&lt;-</span> <span class="fu">which</span><span class="op">(</span><span class="va">layer_info</span> <span class="op">==</span> <span class="st">"WM"</span><span class="op">)</span></span>
<span>  <span class="va">other_counts</span> <span class="op">&lt;-</span> <span class="fu">rowSums</span><span class="op">(</span><span class="va">counts_matrix</span><span class="op">[</span>, <span class="op">-</span><span class="va">white_matter_col</span><span class="op">]</span><span class="op">)</span></span>
<span>  <span class="va">white_matter_counts</span> <span class="op">&lt;-</span> <span class="va">counts_matrix</span><span class="op">[</span>, <span class="va">white_matter_col</span><span class="op">]</span></span>
<span>  <span class="va">new_matrix</span> <span class="op">&lt;-</span> <span class="fu">cbind</span><span class="op">(</span><span class="va">white_matter_counts</span>, <span class="va">other_counts</span><span class="op">)</span></span>
<span>  <span class="fu">colnames</span><span class="op">(</span><span class="va">new_matrix</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu">c</span><span class="op">(</span><span class="fu">paste0</span><span class="op">(</span><span class="st">"white_matter_"</span>, <span class="va">sample_name</span><span class="op">)</span>, <span class="fu">paste0</span><span class="op">(</span><span class="st">"other_"</span>, <span class="va">sample_name</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="kw">return</span><span class="op">(</span><span class="va">new_matrix</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co"># Process each sample and store the resulting matrices</span></span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">sample</span> <span class="kw">in</span> <span class="va">selected_samples</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">new_matrix</span> <span class="op">&lt;-</span> <span class="fu">process_sample</span><span class="op">(</span><span class="va">sample</span>, <span class="va">pseudobulked_objs</span><span class="op">)</span></span>
<span>  <span class="va">all_columns</span><span class="op">[[</span><span class="va">sample</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">new_matrix</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co"># Combine all processed matrices into a single matrix</span></span>
<span><span class="va">combined_matrix</span> <span class="op">&lt;-</span> <span class="fu">do.call</span><span class="op">(</span><span class="va">cbind</span>, <span class="va">all_columns</span><span class="op">)</span></span>
<span><span class="fu">rownames</span><span class="op">(</span><span class="va">combined_matrix</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu">rownames</span><span class="op">(</span><span class="va">pseudobulked_objs</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Create a dataframe for DESeq2 with sample and layer information</span></span>
<span><span class="va">sample</span> <span class="op">&lt;-</span> <span class="fu">rep</span><span class="op">(</span><span class="va">selected_samples</span>, each <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="va">layer</span> <span class="op">&lt;-</span> <span class="fu">rep</span><span class="op">(</span><span class="fu">c</span><span class="op">(</span><span class="st">'WM'</span>, <span class="st">'others'</span><span class="op">)</span>, times <span class="op">=</span> <span class="fu">length</span><span class="op">(</span><span class="va">selected_samples</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">new_dataframe</span> <span class="op">&lt;-</span> <span class="fu">data.frame</span><span class="op">(</span>sample <span class="op">=</span> <span class="va">sample</span>, layer <span class="op">=</span> <span class="va">layer</span><span class="op">)</span></span>
<span><span class="fu">rownames</span><span class="op">(</span><span class="va">new_dataframe</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu">colnames</span><span class="op">(</span><span class="va">combined_matrix</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Perform differential expression analysis using DESeq2</span></span>
<span><span class="co"># Unfortunately, there are still dependency issues between DESeq2 and Seurat,</span></span>
<span><span class="co"># so we recommend not running this part. To prevent execution, we wrap the code in an `if (FALSE)` statement.</span></span>
<span><span class="co">#if (FALSE) {</span></span>
<span><span class="co">#  BiocManager::install("DESeq2")</span></span>
<span><span class="co">#  library(DESeq2)</span></span>
<span><span class="va">dds</span> <span class="op">&lt;-</span> <span class="fu">DESeqDataSetFromMatrix</span><span class="op">(</span>countData <span class="op">=</span> <span class="va">combined_matrix</span>,</span>
<span>                              colData <span class="op">=</span> <span class="va">new_dataframe</span>,</span>
<span>                              design <span class="op">=</span> <span class="op">~</span> <span class="va">layer</span> <span class="op">+</span> <span class="va">sample</span><span class="op">)</span></span>
<span><span class="va">dds</span> <span class="op">&lt;-</span> <span class="fu">DESeq</span><span class="op">(</span><span class="va">dds</span><span class="op">)</span></span>
<span><span class="fu">resultsNames</span><span class="op">(</span><span class="va">dds</span><span class="op">)</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>[1] "Intercept"               "layer_WM_vs_others"
[3] "sample_151669_vs_151508" "sample_151673_vs_151508"</code></pre>
</div>
<div class="codewrapper sourceCode" id="cb34">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">res</span> <span class="op">&lt;-</span> <span class="fu">results</span><span class="op">(</span><span class="va">dds</span>, name <span class="op">=</span> <span class="st">"layer_WM_vs_others"</span><span class="op">)</span></span>
<span><span class="fu">head</span><span class="op">(</span><span class="va">res</span><span class="op">[</span><span class="fu">order</span><span class="op">(</span><span class="va">res</span><span class="op">$</span><span class="va">padj</span><span class="op">)</span>,<span class="op">]</span><span class="op">)</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>log2 fold change (MLE): layer WM vs others
Wald test p-value: layer WM vs others
DataFrame with 6 rows and 6 columns
        baseMean log2FoldChange     lfcSE      stat      pvalue        padj
       &lt;numeric&gt;      &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt;   &lt;numeric&gt;   &lt;numeric&gt;
MOBP    1364.273        3.04042  0.334509   9.08921 9.97603e-20 1.26825e-15
AQP1     160.269        3.22379  0.359589   8.96523 3.09639e-19 1.31215e-15
MBP    16027.210        2.72729  0.303229   8.99418 2.37995e-19 1.31215e-15
MOG      422.622        2.94064  0.357036   8.23624 1.77704e-16 5.64789e-13
MYRF     318.623        2.72961  0.338574   8.06208 7.50046e-16 1.90707e-12
NKX6-2   325.542        2.91717  0.368060   7.92579 2.26698e-15 4.80335e-12</code></pre>
</div>
<div class="codewrapper sourceCode" id="cb36">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#}</span></span></code></pre>
</div>
<figure><img src="fig/de_genes.PNG" alt="Genes with the lowest adjusted p-values from differential expression analysis with DESeq2" class="figure mx-auto d-block"><div class="figcaption">Visium spatial gene expression slide</div>
</figure><p>We have selected to plot spatially the differentially expressed genes
with the highest mean values, namely “MBP” and “MOBP”</p>
<div class="codewrapper sourceCode" id="cb37">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">plot_sample_expression</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">sample</span>, <span class="va">gene</span>, <span class="va">sample_id</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">sample</span><span class="op">@</span><span class="va">meta.data</span><span class="op">$</span><span class="va">temp_feat</span> <span class="op">&lt;-</span> <span class="va">sample</span><span class="op">@</span><span class="va">assays</span><span class="op">[[</span><span class="st">"Spatial"</span><span class="op">]</span><span class="op">]</span><span class="op">$</span><span class="va">counts</span><span class="op">[</span><span class="va">gene</span>,<span class="op">]</span></span>
<span>  <span class="va">p1</span> <span class="op">&lt;-</span> <span class="fu">SpatialFeaturePlot</span><span class="op">(</span><span class="va">sample</span>, features <span class="op">=</span> <span class="st">"temp_feat"</span><span class="op">)</span> <span class="op">+</span></span>
<span>    <span class="fu">ggtitle</span><span class="op">(</span><span class="fu">paste</span><span class="op">(</span><span class="st">"Spatial Expression of"</span>, <span class="va">gene</span>, <span class="st">"in Sample"</span>, <span class="va">sample_id</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span></span>
<span>    <span class="fu">theme</span><span class="op">(</span>plot.title <span class="op">=</span> <span class="fu">element_text</span><span class="op">(</span>hjust <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="kw">return</span><span class="op">(</span><span class="va">p1</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="va">plot_layer_expression</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">sample</span>, <span class="va">sample_id</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">p1</span> <span class="op">&lt;-</span> <span class="fu">SpatialDimPlot</span><span class="op">(</span><span class="va">sample</span>, group.by <span class="op">=</span> <span class="st">"layer_guess"</span><span class="op">)</span> <span class="op">+</span></span>
<span>    <span class="fu">ggtitle</span><span class="op">(</span><span class="fu">paste</span><span class="op">(</span><span class="st">"Layer guess of Sample"</span>, <span class="va">sample_id</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span></span>
<span>    <span class="fu">theme</span><span class="op">(</span>plot.title <span class="op">=</span> <span class="fu">element_text</span><span class="op">(</span>hjust <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span>,</span>
<span>          legend.text <span class="op">=</span> <span class="fu">element_text</span><span class="op">(</span>size <span class="op">=</span> <span class="fl">12</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="kw">return</span><span class="op">(</span><span class="va">p1</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co"># Plot and save the top DE genes across samples</span></span>
<span><span class="va">plots</span> <span class="op">&lt;-</span> <span class="fu">list</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">sample_id</span> <span class="kw">in</span> <span class="va">selected_samples</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">p1</span> <span class="op">&lt;-</span> <span class="fu">plot_sample_expression</span><span class="op">(</span><span class="va">st_objects</span><span class="op">[[</span><span class="va">sample_id</span><span class="op">]</span><span class="op">]</span>, <span class="st">"MOBP"</span>, <span class="va">sample_id</span><span class="op">)</span></span>
<span>  <span class="va">p2</span> <span class="op">&lt;-</span> <span class="fu">plot_sample_expression</span><span class="op">(</span><span class="va">st_objects</span><span class="op">[[</span><span class="va">sample_id</span><span class="op">]</span><span class="op">]</span>, <span class="st">"MBP"</span> , <span class="va">sample_id</span><span class="op">)</span></span>
<span>  <span class="va">p3</span> <span class="op">&lt;-</span> <span class="fu">plot_layer_expression</span><span class="op">(</span><span class="va">st_objects</span><span class="op">[[</span><span class="va">sample_id</span><span class="op">]</span><span class="op">]</span>, <span class="va">sample_id</span><span class="op">)</span></span>
<span>  <span class="va">combined</span> <span class="op">&lt;-</span> <span class="va">p1</span> <span class="op">+</span> <span class="va">p2</span> <span class="op">+</span> <span class="va">p3</span></span>
<span>  <span class="va">plots</span><span class="op">[[</span><span class="va">sample_id</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">combined</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co"># Combine and save plots</span></span>
<span><span class="va">combined_plot</span> <span class="op">&lt;-</span> <span class="fu">wrap_plots</span><span class="op">(</span><span class="va">plots</span>, ncol <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span></code></pre>
</div>
<figure><img src="fig/de_genes_plot.png" class="figure mx-auto d-block"><div class="figcaption">Spatial distribution of the most DE genes for
all samples</div>
</figure><p>As it is evident from the spatila distribution of the genes, they are
mostly expressed specifically in the White Matter for all samples.</p>
</div>
</section><section><h2 class="section-heading" id="other-considerations">Other Considerations<a class="anchor" aria-label="anchor" href="#other-considerations"></a>
</h2>
<hr class="half-width">
<p>We here explored the very basics of differential expression analysis
and differential expression analysis with multiple samples. For batch
correction procedures, such as those just mentioned, may remove
biological variability along with technical variability. An alternative
approach is to perform analyses <em>within</em> samples and then to
perform meta-analysis across them. One intriguing possibility is to
compare rank-based statistics across samples, which should be less
susceptible to batch effects. Another is to cluster across samples based
on overlapping sets of genes within intra-cluster samples. Such an
approach has been applied in the “meta-programs” defined in cancer by <a href="https://pubmed.ncbi.nlm.nih.gov/37258682/" class="external-link">Gavish and
colleagues</a>.</p>
<p>There is unlikely to be one turn-key approach to addressing the above
issues. You will likely need to explore the data – and that exploration
should be guided by some biological expectations that anchor your
choices.</p>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>Differential expression testing pinpoints genes with significant
expression variations across regions or clusters.</li>
<li>Moran’s I statistic reveals spatial autocorrelation in gene
expression, critical for examining spatially dependent biological
activities.</li>
<li>Moran’s I algorithm effectively identifies genes expressed in
anatomically distinct regions, as validated from the correlation
analysis with the DE genes from the annotated regions.</li>
</ul>
</div>
</div>
</div>
<p>#<code>{r echo=FALSE,include=FALSE} #save_seurat_object(obj = sct_st, file_prefix = 'detesting') #</code></p>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-final-exercise"><p>Content from <a href="final-exercise.html">Putting it all Together</a></p>
<hr>
<p>Last updated on 2025-03-04 |

        <a href="https://github.com/smcclatchy/spatial-transcriptomics/edit/main/episodes/final-exercise.Rmd" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>How do I put the whole spatial transcriptomics analysis
together?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Understand the steps in spatial transcriptomics analysis.</li>
<li>Perform a spatial transcriptomics analysis on another sample.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<hr class="half-width">
<p>Over the past day and a half, we have reviewed the steps in a spatial
transcriptomics analysis. There were many steps and many lines of code.
In this final lesson, you will run through the spatial transcriptomics
analysis on your own with another sample.</p>
<div id="challenge-1-reading-in-a-new-sample." class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-1-reading-in-a-new-sample." class="callout-inner">
<h3 class="callout-title">Challenge 1: Reading in a new sample.</h3>
<div class="callout-content">
<p>Look back through the lessons. What libraries and auxiliary functions
did we use? Load those in now.</p>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" data-bs-parent="#accordionSolution1" aria-labelledby="headingSolution1">
<div class="accordion-body">
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">suppressPackageStartupMessages</span><span class="op">(</span><span class="kw">library</span><span class="op">(</span><span class="va">tidyverse</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu">suppressPackageStartupMessages</span><span class="op">(</span><span class="kw">library</span><span class="op">(</span><span class="va">Seurat</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu">suppressPackageStartupMessages</span><span class="op">(</span><span class="kw">library</span><span class="op">(</span><span class="va">spacexr</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="kw">source</span><span class="op">(</span><span class="st">"https://raw.githubusercontent.com/smcclatchy/spatial-transcriptomics/main/code/spatial_utils.R"</span><span class="op">)</span></span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="challenge-2-reading-in-a-new-sample." class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-2-reading-in-a-new-sample." class="callout-inner">
<h3 class="callout-title">Challenge 2: Reading in a new sample.</h3>
<div class="callout-content">
<p>The publication which used this data has several tissue sections. As
part of the setup, you should have downloaded sample 151508. Look in the
Data Preprocessing lesson and read in the filtered sample file for this
sample.</p>
</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2"> Show me the solution </h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" data-bs-parent="#accordionSolution2" aria-labelledby="headingSolution2">
<div class="accordion-body">
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">st_obj</span> <span class="op">&lt;-</span> <span class="fu">Load10X_Spatial</span><span class="op">(</span>data.dir  <span class="op">=</span> <span class="st">"./data/151508"</span>, </span>
<span>                          filename  <span class="op">=</span> <span class="st">"151508_raw_feature_bc_matrix.h5"</span><span class="op">)</span></span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="challenge-3-reading-in-sample-metadata." class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-3-reading-in-sample-metadata." class="callout-inner">
<h3 class="callout-title">Challenge 3: Reading in sample metadata.</h3>
<div class="callout-content">
<p>In the Data Preprocessing lesson, we showed you how to read in sample
metadata and add it to the Seurat object. Find that code and add the new
sample’s metadata to your Seurat object.</p>
</div>
</div>
</div>
<div id="accordionSolution3" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution3" aria-expanded="false" aria-controls="collapseSolution3">
  <h4 class="accordion-header" id="headingSolution3"> Show me the solution </h4>
</button>
<div id="collapseSolution3" class="accordion-collapse collapse" data-bs-parent="#accordionSolution3" aria-labelledby="headingSolution3">
<div class="accordion-body">
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Read in the tissue spot positions.</span></span>
<span><span class="va">tissue_position</span> <span class="op">&lt;-</span> <span class="fu">read_csv</span><span class="op">(</span><span class="st">"./data/151508/spatial/tissue_positions_list.csv"</span>,</span>
<span>                            col_names <span class="op">=</span> <span class="cn">FALSE</span>, show_col_types <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span> <span class="op">%&gt;%</span> </span>
<span>                     <span class="fu">column_to_rownames</span><span class="op">(</span><span class="st">'X1'</span><span class="op">)</span></span>
<span><span class="fu">colnames</span><span class="op">(</span><span class="va">tissue_position</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu">c</span><span class="op">(</span><span class="st">"in_tissue"</span>, </span>
<span>                               <span class="st">"array_row"</span>, </span>
<span>                               <span class="st">"array_col"</span>, </span>
<span>                               <span class="st">"pxl_row_in_fullres"</span>, </span>
<span>                               <span class="st">"pxl_col_in_fullres"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Align the spot barcodes to match between the Seurat object and the new</span></span>
<span><span class="co"># metadata.</span></span>
<span><span class="va">tissue_position</span> <span class="op">&lt;-</span> <span class="va">tissue_position</span><span class="op">[</span><span class="fu">Cells</span><span class="op">(</span><span class="va">st_obj</span><span class="op">)</span>,<span class="op">]</span></span>
<span><span class="fu">stopifnot</span><span class="op">(</span><span class="fu">rownames</span><span class="op">(</span><span class="va">tissue_position</span><span class="op">)</span> <span class="op">==</span> <span class="fu">Cells</span><span class="op">(</span><span class="va">st_obj</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Add the metadata to the Seurat object.</span></span>
<span><span class="va">st_obj</span> <span class="op">&lt;-</span> <span class="fu">AddMetaData</span><span class="op">(</span>object <span class="op">=</span> <span class="va">st_obj</span>, metadata <span class="op">=</span> <span class="va">tissue_position</span><span class="op">)</span></span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="challenge-4-plot-the-spot-positions-over-the-tissue-section." class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-4-plot-the-spot-positions-over-the-tissue-section." class="callout-inner">
<h3 class="callout-title">Challenge 4: Plot the spot positions over the tissue section.</h3>
<div class="callout-content">
<p>Look for the code to plot the number of counts in each spot in the
Data Preprocessing lesson and adapt it to your tissue sample.</p>
</div>
</div>
</div>
<div id="accordionSolution4" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution4" aria-expanded="false" aria-controls="collapseSolution4">
  <h4 class="accordion-header" id="headingSolution4"> Show me the solution </h4>
</button>
<div id="collapseSolution4" class="accordion-collapse collapse" data-bs-parent="#accordionSolution4" aria-labelledby="headingSolution4">
<div class="accordion-body">
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">SpatialFeaturePlot</span><span class="op">(</span><span class="va">st_obj</span>, features <span class="op">=</span> <span class="st">"nCount_Spatial"</span><span class="op">)</span></span></code></pre>
</div>
<figure><img src="fig/final-exercise-rendered-unnamed-chunk-4-1.png" style="display: block; margin: auto;" class="figure mx-auto d-block"></figure>
</div>
</div>
</div>
</div>
<div id="challenge-5-filter-counts-to-retain-expressed-genes." class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-5-filter-counts-to-retain-expressed-genes." class="callout-inner">
<h3 class="callout-title">Challenge 5: Filter counts to retain expressed genes.</h3>
<div class="callout-content">
<p>Look in the Data Preprocessing lesson and filter the counts in your
Seurat object to retain genes which have a total sum across all samples
of at least 10 counts. How many genes did you end up with?</p>
</div>
</div>
</div>
<div id="accordionSolution5" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution5" aria-expanded="false" aria-controls="collapseSolution5">
  <h4 class="accordion-header" id="headingSolution5"> Show me the solution </h4>
</button>
<div id="collapseSolution5" class="accordion-collapse collapse" data-bs-parent="#accordionSolution5" aria-labelledby="headingSolution5">
<div class="accordion-body">
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Get the counts from the Seurat object.</span></span>
<span><span class="va">counts</span>     <span class="op">&lt;-</span> <span class="fu">LayerData</span><span class="op">(</span><span class="va">st_obj</span>, <span class="st">'counts'</span><span class="op">)</span></span>
<span><span class="co"># Sum total counts across all samples for each gene.</span></span>
<span><span class="va">gene_sums</span>  <span class="op">&lt;-</span> <span class="fu">rowSums</span><span class="op">(</span><span class="va">counts</span><span class="op">)</span></span>
<span><span class="co"># Select genes with total counts above our threshold. </span></span>
<span><span class="va">keep_genes</span> <span class="op">&lt;-</span> <span class="fu">which</span><span class="op">(</span><span class="va">gene_sums</span> <span class="op">&gt;</span> <span class="fl">10</span><span class="op">)</span></span>
<span><span class="co"># Filter the Seurat object.</span></span>
<span><span class="va">st_obj</span>     <span class="op">&lt;-</span> <span class="va">st_obj</span><span class="op">[</span><span class="va">keep_genes</span>,<span class="op">]</span></span>
<span><span class="co"># Print out the number of genes that we retained.</span></span>
<span><span class="fu">print</span><span class="op">(</span><span class="fu">length</span><span class="op">(</span><span class="va">keep_genes</span><span class="op">)</span><span class="op">)</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>[1] 15311</code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="challenge-6-normalize-data-using-sctransform" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-6-normalize-data-using-sctransform" class="callout-inner">
<h3 class="callout-title">Challenge 6: Normalize data using SCTransform</h3>
<div class="callout-content">
<p>In the Normalization lesson, we used the SCTransform to normalize the
counts. Normalize the counts in your Seurat object an plot the mean
expression versus the residual variance for each gene. Use the built in
Seurat function to do this. How many variable genes did the method
select?</p>
</div>
</div>
</div>
<div id="accordionSolution6" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution6" aria-expanded="false" aria-controls="collapseSolution6">
  <h4 class="accordion-header" id="headingSolution6"> Show me the solution </h4>
</button>
<div id="collapseSolution6" class="accordion-collapse collapse" data-bs-parent="#accordionSolution6" aria-labelledby="headingSolution6">
<div class="accordion-body">
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Perform SCTransform on the counts.</span></span>
<span><span class="va">st_obj</span> <span class="op">&lt;-</span> <span class="fu">SCTransform</span><span class="op">(</span><span class="va">st_obj</span>, </span>
<span>                      assay <span class="op">=</span> <span class="st">"Spatial"</span><span class="op">)</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>Running SCTransform on assay: Spatial</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>Running SCTransform on layer: counts</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>vst.flavor='v2' set. Using model with fixed slope and excluding poisson genes.</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>`vst.flavor` is set to 'v2' but could not find glmGamPoi installed.
Please install the glmGamPoi package for much faster estimation.
--------------------------------------------
install.packages('BiocManager')
BiocManager::install('glmGamPoi')
--------------------------------------------
Falling back to native (slower) implementation.</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>Variance stabilizing transformation of count matrix of size 15311 by 4992</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>Model formula is y ~ log_umi</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>Get Negative Binomial regression parameters per gene</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>Using 2000 genes, 4992 cells</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">WARNING<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="warning" tabindex="0"><code>Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">WARNING<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="warning" tabindex="0"><code>Warning in glm.nb(formula = as.formula(new_formula), data = data): alternation
limit reached</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">WARNING<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="warning" tabindex="0"><code>Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">WARNING<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="warning" tabindex="0"><code>Warning in glm.nb(formula = as.formula(new_formula), data = data): alternation
limit reached</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">WARNING<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="warning" tabindex="0"><code>Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">WARNING<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="warning" tabindex="0"><code>Warning in glm.nb(formula = as.formula(new_formula), data = data): alternation
limit reached</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">WARNING<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="warning" tabindex="0"><code>Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">WARNING<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="warning" tabindex="0"><code>Warning in glm.nb(formula = as.formula(new_formula), data = data): alternation
limit reached</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">WARNING<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="warning" tabindex="0"><code>Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">WARNING<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="warning" tabindex="0"><code>Warning in glm.nb(formula = as.formula(new_formula), data = data): alternation
limit reached</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">WARNING<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="warning" tabindex="0"><code>Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">WARNING<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="warning" tabindex="0"><code>Warning in glm.nb(formula = as.formula(new_formula), data = data): alternation
limit reached</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">WARNING<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="warning" tabindex="0"><code>Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">WARNING<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="warning" tabindex="0"><code>Warning in glm.nb(formula = as.formula(new_formula), data = data): alternation
limit reached</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">WARNING<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="warning" tabindex="0"><code>Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">WARNING<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="warning" tabindex="0"><code>Warning in glm.nb(formula = as.formula(new_formula), data = data): alternation
limit reached</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">WARNING<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="warning" tabindex="0"><code>Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">WARNING<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="warning" tabindex="0"><code>Warning in glm.nb(formula = as.formula(new_formula), data = data): alternation
limit reached</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">WARNING<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="warning" tabindex="0"><code>Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">WARNING<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="warning" tabindex="0"><code>Warning in glm.nb(formula = as.formula(new_formula), data = data): alternation
limit reached</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">WARNING<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="warning" tabindex="0"><code>Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">WARNING<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="warning" tabindex="0"><code>Warning in glm.nb(formula = as.formula(new_formula), data = data): alternation
limit reached</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">WARNING<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="warning" tabindex="0"><code>Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached
Warning in theta.ml(Y, mu, sum(w), w, limit = control$maxit, trace =
control$trace &gt; : iteration limit reached</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>Found 11 outliers - those will be ignored in fitting/regularization step</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>Second step: Get residuals using fitted parameters for 15311 genes</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>Computing corrected count matrix for 15311 genes</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>Calculating gene attributes</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>Wall clock passed: Time difference of 5.160943 mins</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>Determine variable features</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>Centering data matrix</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>Set default assay to SCT</code></pre>
</div>
<div class="codewrapper sourceCode" id="cb47">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Plot the mean veruss the variance for each gene.</span></span>
<span><span class="fu">VariableFeaturePlot</span><span class="op">(</span><span class="va">st_obj</span>, log <span class="op">=</span> <span class="cn">NULL</span><span class="op">)</span></span></code></pre>
</div>
<figure><img src="fig/final-exercise-rendered-unnamed-chunk-6-1.png" style="display: block; margin: auto;" class="figure mx-auto d-block"></figure><div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>Running SCTransform on assay: Spatial
Running SCTransform on layer: counts
vst.flavor='v2' set. Using model with fixed slope and excluding poisson genes.
Variance stabilizing transformation of count matrix of size 15311 by 4992
Model formula is y ~ log_umi
Get Negative Binomial regression parameters per gene
Using 2000 genes, 4992 cells
Found 91 outliers - those will be ignored in fitting/regularization step

Second step: Get residuals using fitted parameters for 15311 genes
Computing corrected count matrix for 15311 genes
Calculating gene attributes
Wall clock passed: Time difference of 36.59206 secs
Determine variable features
Centering data matrix
  |===================================================================================================================================================================| 100%
Set default assay to SCT</code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="challenge-7-apply-dimensionality-reduction-to-your-data." class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-7-apply-dimensionality-reduction-to-your-data." class="callout-inner">
<h3 class="callout-title">Challenge 7: Apply dimensionality reduction to your data.</h3>
<div class="callout-content">
<p>In the Feature Selection lesson, we used the variable genes to
calculate principal components of the data. Scale the data, calculate 75
PCs and plot the “Elbow Plot” of PCs versus standard deviation accounted
for by each PC.</p>
</div>
</div>
</div>
<div id="accordionSolution7" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution7" aria-expanded="false" aria-controls="collapseSolution7">
  <h4 class="accordion-header" id="headingSolution7"> Show me the solution </h4>
</button>
<div id="collapseSolution7" class="accordion-collapse collapse" data-bs-parent="#accordionSolution7" aria-labelledby="headingSolution7">
<div class="accordion-body">
<div class="codewrapper sourceCode" id="cb49">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">num_pcs</span> <span class="op">&lt;-</span> <span class="fl">75</span></span>
<span><span class="va">st_obj</span>  <span class="op">&lt;-</span> <span class="va">st_obj</span> <span class="op">%&gt;%</span></span>
<span>             <span class="fu">ScaleData</span><span class="op">(</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>             <span class="fu">RunPCA</span><span class="op">(</span>npcs <span class="op">=</span> <span class="va">num_pcs</span>, verbose <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>Centering and scaling data matrix</code></pre>
</div>
<div class="codewrapper sourceCode" id="cb51">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">ElbowPlot</span><span class="op">(</span><span class="va">st_obj</span>, ndims <span class="op">=</span> <span class="va">num_pcs</span><span class="op">)</span></span></code></pre>
</div>
<figure><img src="fig/final-exercise-rendered-unnamed-chunk-7-1.png" style="display: block; margin: auto;" class="figure mx-auto d-block"></figure>
</div>
</div>
</div>
</div>

<div id="challenge-8-cluster-the-spots-in-your-data" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-8-cluster-the-spots-in-your-data" class="callout-inner">
<h3 class="callout-title">Challenge 8: Cluster the spots in your data</h3>
<div class="callout-content">
<p>In the Feature Selection lesson, we made a call about how many PCs to
use. Make some decision about how many PCs you will use and assign this
to a variable called “num_pcs”. Also, select a cluster resolution for
the clustering function. It may be instructive for each person in the
class to use a different number of PCs and compare results. What new
column was added to the Seurat object metadata by the clustering
algorithm?</p>
</div>
</div>
</div>
<div id="accordionSolution8" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution8" aria-expanded="false" aria-controls="collapseSolution8">
  <h4 class="accordion-header" id="headingSolution8"> Show me the solution </h4>
</button>
<div id="collapseSolution8" class="accordion-collapse collapse" data-bs-parent="#accordionSolution8" aria-labelledby="headingSolution8">
<div class="accordion-body">
<p>We selected 50 PCs and a cluster resoltion of 1 for this exercise.
This may not be optimal. You will have a chance to vary these parameters
in a later exercise.</p>
<div class="codewrapper sourceCode" id="cb52">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">num_pcs</span> <span class="op">&lt;-</span> <span class="fl">50</span></span>
<span><span class="va">st_obj</span>  <span class="op">&lt;-</span> <span class="va">st_obj</span> <span class="op">%&gt;%</span></span>
<span>             <span class="fu">FindNeighbors</span><span class="op">(</span>reduction <span class="op">=</span> <span class="st">"pca"</span>, </span>
<span>                           dims      <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="va">num_pcs</span><span class="op">)</span> <span class="op">%&gt;%</span> </span>
<span>             <span class="fu">FindClusters</span><span class="op">(</span>resolution <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>Computing nearest neighbor graph</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>Computing SNN</code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck

Number of nodes: 4992
Number of edges: 227931

Running Louvain algorithm...
Maximum modularity in 10 random starts: 0.7701
Number of communities: 9
Elapsed time: 0 seconds</code></pre>
</div>
<div class="codewrapper sourceCode" id="cb56">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">colnames</span><span class="op">(</span><span class="va">st_obj</span><span class="op">[[</span><span class="op">]</span><span class="op">]</span><span class="op">)</span><span class="op">[</span><span class="fu">ncol</span><span class="op">(</span><span class="va">st_obj</span><span class="op">[[</span><span class="op">]</span><span class="op">]</span><span class="op">)</span><span class="op">]</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>[1] "seurat_clusters"</code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="challenge-9-plot-umap-of-spot-clusters." class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-9-plot-umap-of-spot-clusters." class="callout-inner">
<h3 class="callout-title">Challenge 9: Plot UMAP of spot clusters.</h3>
<div class="callout-content">
<p>Look in the Feature Selection lesson and find the code to run UMAP
and plot the spot clusters in UMAP space. You can use the default colors
in Seurat.</p>
</div>
</div>
</div>
<div id="accordionSolution9" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution9" aria-expanded="false" aria-controls="collapseSolution9">
  <h4 class="accordion-header" id="headingSolution9"> Show me the solution </h4>
</button>
<div id="collapseSolution9" class="accordion-collapse collapse" data-bs-parent="#accordionSolution9" aria-labelledby="headingSolution9">
<div class="accordion-body">
<div class="codewrapper sourceCode" id="cb58">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">st_obj</span> <span class="op">&lt;-</span> <span class="fu">RunUMAP</span><span class="op">(</span><span class="va">st_obj</span>, </span>
<span>                  reduction <span class="op">=</span> <span class="st">'pca'</span>, </span>
<span>                  dims      <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="va">num_pcs</span>, </span>
<span>                  verbose   <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">WARNING<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="warning" tabindex="0"><code>Warning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric
To use Python UMAP via reticulate, set umap.method to 'umap-learn' and metric to 'correlation'
This message will be shown once per session</code></pre>
</div>
<div class="codewrapper sourceCode" id="cb60">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">UMAPPlot</span><span class="op">(</span><span class="va">st_obj</span>, </span>
<span>         label      <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>         pt.size    <span class="op">=</span> <span class="fl">2</span>,</span>
<span>         group.by   <span class="op">=</span> <span class="st">"seurat_clusters"</span>,</span>
<span>         label.size <span class="op">=</span> <span class="fl">6</span><span class="op">)</span></span></code></pre>
</div>
<figure><img src="fig/final-exercise-rendered-unnamed-chunk-9-1.png" style="display: block; margin: auto;" class="figure mx-auto d-block"></figure>
</div>
</div>
</div>
</div>
<div id="challenge-10-plot-spot-clusters-over-tissue-section" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-10-plot-spot-clusters-over-tissue-section" class="callout-inner">
<h3 class="callout-title">Challenge 10: Plot spot clusters over tissue section</h3>
<div class="callout-content">
<p>Look in the Feature Selection lesson and find the code to plot the
spots in the tissue section, colored by cluster. Compare this to the
tissue section Supplemental Figure 5 in <a href="https://www.nature.com/articles/s41593-020-00787-0#Sec33" class="external-link">Maynard
et al.</a>.</p>
</div>
</div>
</div>
<div id="accordionSolution10" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution10" aria-expanded="false" aria-controls="collapseSolution10">
  <h4 class="accordion-header" id="headingSolution10"> Show me the solution </h4>
</button>
<div id="collapseSolution10" class="accordion-collapse collapse" data-bs-parent="#accordionSolution10" aria-labelledby="headingSolution10">
<div class="accordion-body">
<div class="codewrapper sourceCode" id="cb61">
<h3 class="code-label">R<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">SpatialDimPlot</span><span class="op">(</span><span class="va">st_obj</span>, </span>
<span>               group.by <span class="op">=</span> <span class="st">"seurat_clusters"</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">ggtitle</span><span class="op">(</span>label <span class="op">=</span> <span class="st">'Sample 151508'</span><span class="op">)</span></span></code></pre>
</div>
<figure><img src="fig/final-exercise-rendered-unnamed-chunk-10-1.png" style="display: block; margin: auto;" class="figure mx-auto d-block"></figure>
</div>
</div>
</div>
</div>
<div id="challenge-11-varying-number-of-pcs-and-cluster-resolution." class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-11-varying-number-of-pcs-and-cluster-resolution." class="callout-inner">
<h3 class="callout-title">Challenge 11: Varying number of PCs and cluster resolution.</h3>
<div class="callout-content">
<p>Return to Challenge 8 and change either the number of PCs or the
cluster resolution and re-run the subsequent Challenges. How does this
change the output? Does a certain set of values make the SpatialDimPlot
look more like the results in the manuscript?</p>
</div>
</div>
</div>
<div id="accordionSolution11" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution11" aria-expanded="false" aria-controls="collapseSolution11">
  <h4 class="accordion-header" id="headingSolution11"> Show me the solution </h4>
</button>
<div id="collapseSolution11" class="accordion-collapse collapse" data-bs-parent="#accordionSolution11" aria-labelledby="headingSolution11">
<div class="accordion-body">
<p>For class discussion.</p>
</div>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>There are many decisions which need to be made in spatial
transcriptomics.</li>
<li>It is essential to have an understanding of the tissue morphology
before proceeding with a spatial transcriptomics analysis.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section>
</div>
    </main>
</div>
<!-- END  : inst/pkgdown/templates/content-extra.html -->

      </div>
<!--/div.row-->
      		<footer class="row footer mx-md-3"><hr>
<div class="col-md-6">
        <p>This lesson is subject to the <a href="CODE_OF_CONDUCT.html">Code of Conduct</a></p>
        <p>

        <a href="https://github.com/smcclatchy/spatial-transcriptomics/edit/main/README.md" class="external-link">Edit on GitHub</a>

	
        | <a href="https://github.com/smcclatchy/spatial-transcriptomics/blob/main/CONTRIBUTING.md" class="external-link">Contributing</a>
        | <a href="https://github.com/smcclatchy/spatial-transcriptomics/" class="external-link">Source</a></p>
				<p><a href="https://github.com/smcclatchy/spatial-transcriptomics/blob/main/CITATION.cff" class="external-link">Cite</a> | <a href="mailto:susan.mcclatchy@jax.org">Contact</a> | <a href="https://carpentries.org/about/" class="external-link">About</a></p>
			</div>
			<div class="col-md-6">

        <p>Materials licensed under <a href="LICENSE.html">CC-BY 4.0</a> by the authors</p>

        <p>Template licensed under <a href="https://creativecommons.org/licenses/by-sa/4.0/" class="external-link">CC-BY 4.0</a> by <a href="https://carpentries.org/" class="external-link">The Carpentries</a></p>
        <p>Built with <a href="https://github.com/epiverse-trace/sandpaper/tree/patch-renv-github-bug" class="external-link">sandpaper (0.16.11)</a>, <a href="https://github.com/carpentries/pegboard/tree/5e0d711121a581777d83cf270e298c933f112d52" class="external-link">pegboard (0.7.9)</a>, and <a href="https://github.com/carpentries/varnish/tree/1.0.5" class="external-link">varnish (1.0.5)</a></p>
			</div>
		</footer>
</div> <!-- / div.container -->
	<div id="to-top">
		<a href="#top">
      <i class="search-icon" data-feather="arrow-up" role="img" aria-label="Back To Top"></i><br><!-- <span class="d-none d-sm-none d-md-none d-lg-none d-xl-block">Back</span> To Top --><span class="d-none d-sm-none d-md-none d-lg-none d-xl-block">Back</span> To Top
		</a>
	</div>
  <script type="application/ld+json">
    {
  "@context": "https://schema.org",
  "@type": "TrainingMaterial",
  "@id": "https://smcclatchy.github.io/spatial-transcriptomics/aio.html",
  "inLanguage": "en",
  "dct:conformsTo": "https://bioschemas.org/profiles/TrainingMaterial/1.0-RELEASE",
  "description": "A Carpentries Lesson teaching foundational data and coding skills to researchers worldwide",
  "keywords": "software, data, lesson, The Carpentries, transcriptome, Visium, cancer",
  "name": "All in One View",
  "creativeWorkStatus": "active",
  "url": "https://smcclatchy.github.io/spatial-transcriptomics/aio.html",
  "identifier": "https://smcclatchy.github.io/spatial-transcriptomics/aio.html",
  "dateCreated": "2024-03-01",
  "dateModified": "2025-03-04",
  "datePublished": "2025-03-04"
}

  </script><script>
		feather.replace();
	</script>
</body>
</html><!-- END:   inst/pkgdown/templates/layout.html-->

